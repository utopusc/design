"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vaul@0.9.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/vaul@0.9.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/vaul@0.9.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/vaul/dist/index.mjs":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/vaul@0.9.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/vaul/dist/index.mjs ***!
  \****************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Drawer: () => (/* binding */ Drawer)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @radix-ui/react-dialog */ \"(ssr)/./node_modules/.pnpm/@radix-ui+react-dialog@1.1.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@radix-ui/react-dialog/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.7_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Drawer auto */ function __insertCSS(code) {\n    if (!code || typeof document == \"undefined\") return;\n    let head = document.head || document.getElementsByTagName(\"head\")[0];\n    let style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    head.appendChild(style);\n    style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));\n}\n\n\n\nconst DrawerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    drawerRef: {\n        current: null\n    },\n    overlayRef: {\n        current: null\n    },\n    scaleBackground: ()=>{},\n    onPress: ()=>{},\n    onRelease: ()=>{},\n    onDrag: ()=>{},\n    onNestedDrag: ()=>{},\n    onNestedOpenChange: ()=>{},\n    onNestedRelease: ()=>{},\n    openProp: undefined,\n    dismissible: false,\n    handleOnly: false,\n    isOpen: false,\n    isDragging: false,\n    keyboardIsOpen: {\n        current: false\n    },\n    snapPointsOffset: null,\n    snapPoints: null,\n    modal: false,\n    shouldFade: false,\n    activeSnapPoint: null,\n    onOpenChange: ()=>{},\n    setActiveSnapPoint: ()=>{},\n    visible: false,\n    closeDrawer: ()=>{},\n    setVisible: ()=>{},\n    direction: \"bottom\"\n});\nconst useDrawerContext = ()=>{\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DrawerContext);\n    if (!context) {\n        throw new Error(\"useDrawerContext must be used within a Drawer.Root\");\n    }\n    return context;\n};\n__insertCSS(\"[vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1)}[vaul-drawer][vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[vaul-drawer][vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[vaul-drawer][vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[vaul-drawer][vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}.vaul-dragging .vaul-scrollable [vault-drawer-direction=top]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=bottom]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=left]{overflow-x:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=right]{overflow-x:hidden!important}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-overlay]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[vaul-overlay][vaul-drawer-visible=true]{opacity:1}[vaul-drawer]::after{content:'';position:absolute;background:inherit;background-color:inherit}[vaul-drawer][vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[vaul-drawer][vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[vaul-handle]{display:block;position:relative;opacity:.8;margin-left:auto;margin-right:auto;height:5px;width:56px;border-radius:1rem;touch-action:pan-y;cursor:grab}[vaul-handle]:active,[vaul-handle]:hover{opacity:1}[vaul-handle]:active{cursor:grabbing}[vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}[vaul-overlay][vaul-snap-points=true]:not([vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[vaul-overlay][vaul-snap-points-overlay=true]:not([vaul-drawer-visible=false]){opacity:1}@media (hover:hover) and (pointer:fine){[vaul-drawer]{user-select:none}}@media (pointer:fine){[vaul-handle-hitarea]:{width:100%;height:100%}}\");\n// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction chain(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks){\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\nfunction isMac() {\n    return testPlatform(/^Mac/);\n}\nfunction isIPhone() {\n    return testPlatform(/^iPhone/);\n}\nfunction isIPad() {\n    return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    isMac() && navigator.maxTouchPoints > 1;\n}\nfunction isIOS() {\n    return isIPhone() || isIPad();\n}\nfunction testPlatform(re) {\n    return  false ? 0 : undefined;\n}\n// @ts-ignore\nconst visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction isScrollable(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\nfunction getScrollParent(node) {\n    if (isScrollable(node)) {\n        node = node.parentElement;\n    }\n    while(node && !isScrollable(node)){\n        node = node.parentElement;\n    }\n    return node || document.scrollingElement || document.documentElement;\n}\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */ function usePreventScroll(options = {}) {\n    let { isDisabled } = options;\n    useIsomorphicLayoutEffect(()=>{\n        if (isDisabled) {\n            return;\n        }\n        preventScrollCount++;\n        if (preventScrollCount === 1) {\n            if (isIOS()) {\n                restore = preventScrollMobileSafari();\n            } else {\n                restore = preventScrollStandard();\n            }\n        }\n        return ()=>{\n            preventScrollCount--;\n            if (preventScrollCount === 0) {\n                restore();\n            }\n        };\n    }, [\n        isDisabled\n    ]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n    return chain(setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n    let scrollable;\n    let lastY = 0;\n    let onTouchStart = (e)=>{\n        // Store the nearest scrollable parent element from the element that the user touched.\n        scrollable = getScrollParent(e.target);\n        if (scrollable === document.documentElement && scrollable === document.body) {\n            return;\n        }\n        lastY = e.changedTouches[0].pageY;\n    };\n    let onTouchMove = (e)=>{\n        // Prevent scrolling the window.\n        if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n            e.preventDefault();\n            return;\n        }\n        // Prevent scrolling up when at the top and scrolling down when at the bottom\n        // of a nested scrollable area, otherwise mobile Safari will start scrolling\n        // the window instead. Unfortunately, this disables bounce scrolling when at\n        // the top but it's the best we can do.\n        let y = e.changedTouches[0].pageY;\n        let scrollTop = scrollable.scrollTop;\n        let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n        if (bottom === 0) {\n            return;\n        }\n        if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {\n            e.preventDefault();\n        }\n        lastY = y;\n    };\n    let onTouchEnd = (e)=>{\n        let target = e.target;\n        // Apply this change if we're not already focused on the target element\n        if (isInput(target) && target !== document.activeElement) {\n            e.preventDefault();\n            // Apply a transform to trick Safari into thinking the input is at the top of the page\n            // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n            // be done before the \"focus\" event, so we have to focus the element ourselves.\n            target.style.transform = \"translateY(-2000px)\";\n            target.focus();\n            requestAnimationFrame(()=>{\n                target.style.transform = \"\";\n            });\n        }\n    };\n    let onFocus = (e)=>{\n        let target = e.target;\n        if (isInput(target)) {\n            // Transform also needs to be applied in the focus event in cases where focus moves\n            // other than tapping on an input directly, e.g. the next/previous buttons in the\n            // software keyboard. In these cases, it seems applying the transform in the focus event\n            // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n            target.style.transform = \"translateY(-2000px)\";\n            requestAnimationFrame(()=>{\n                target.style.transform = \"\";\n                // This will have prevented the browser from scrolling the focused element into view,\n                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n                if (visualViewport) {\n                    if (visualViewport.height < window.innerHeight) {\n                        // If the keyboard is already visible, do this after one additional frame\n                        // to wait for the transform to be removed.\n                        requestAnimationFrame(()=>{\n                            scrollIntoView(target);\n                        });\n                    } else {\n                        // Otherwise, wait for the visual viewport to resize before scrolling so we can\n                        // measure the correct position to scroll to.\n                        visualViewport.addEventListener(\"resize\", ()=>scrollIntoView(target), {\n                            once: true\n                        });\n                    }\n                }\n            });\n        }\n    };\n    let onWindowScroll = ()=>{\n        // Last resort. If the window scrolled, scroll it back to the top.\n        // It should always be at the top because the body will have a negative margin (see below).\n        window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    let restoreStyles = chain(setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`));\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n    let removeEvents = chain(addEvent(document, \"touchstart\", onTouchStart, {\n        passive: false,\n        capture: true\n    }), addEvent(document, \"touchmove\", onTouchMove, {\n        passive: false,\n        capture: true\n    }), addEvent(document, \"touchend\", onTouchEnd, {\n        passive: false,\n        capture: true\n    }), addEvent(document, \"focus\", onFocus, true), addEvent(window, \"scroll\", onWindowScroll));\n    return ()=>{\n        // Restore styles and scroll the page back to where it was.\n        restoreStyles();\n        removeEvents();\n        window.scrollTo(scrollX, scrollY);\n    };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element, style, value) {\n    let cur = element.style[style];\n    element.style[style] = value;\n    return ()=>{\n        element.style[style] = cur;\n    };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent(target, event, handler, options) {\n    // @ts-ignore\n    target.addEventListener(event, handler, options);\n    return ()=>{\n        // @ts-ignore\n        target.removeEventListener(event, handler, options);\n    };\n}\nfunction scrollIntoView(target) {\n    let root = document.scrollingElement || document.documentElement;\n    while(target && target !== root){\n        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n        let scrollable = getScrollParent(target);\n        if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n            let scrollableTop = scrollable.getBoundingClientRect().top;\n            let targetTop = target.getBoundingClientRect().top;\n            let targetBottom = target.getBoundingClientRect().bottom;\n            const keyboardHeight = scrollable.getBoundingClientRect().bottom;\n            if (targetBottom > keyboardHeight) {\n                scrollable.scrollTop += targetTop - scrollableTop;\n            }\n        }\n        // @ts-ignore\n        target = scrollable.parentElement;\n    }\n}\nfunction isInput(target) {\n    return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n// This code comes from https://github.com/radix-ui/primitives/tree/main/packages/react/compose-refs\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */ function setRef(ref, value) {\n    if (typeof ref === \"function\") {\n        ref(value);\n    } else if (ref !== null && ref !== undefined) {\n        ref.current = value;\n    }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */ function composeRefs(...refs) {\n    return (node)=>refs.forEach((ref)=>setRef(ref, node));\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */ function useComposedRefs(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(composeRefs(...refs), refs);\n}\nlet previousBodyPosition = null;\nfunction usePositionFixed({ isOpen, modal, nested, hasBeenOpened, preventScrollRestoration, noBodyStyles }) {\n    const [activeUrl, setActiveUrl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=> false ? 0 : \"\");\n    const scrollPos = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const setPositionFixed = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        // If previousBodyPosition is already set, don't set it again.\n        if (previousBodyPosition === null && isOpen && !noBodyStyles) {\n            previousBodyPosition = {\n                position: document.body.style.position,\n                top: document.body.style.top,\n                left: document.body.style.left,\n                height: document.body.style.height,\n                right: \"unset\"\n            };\n            // Update the dom inside an animation frame\n            const { scrollX, innerHeight } = window;\n            document.body.style.setProperty(\"position\", \"fixed\", \"important\");\n            Object.assign(document.body.style, {\n                top: `${-scrollPos.current}px`,\n                left: `${-scrollX}px`,\n                right: \"0px\",\n                height: \"auto\"\n            });\n            window.setTimeout(()=>window.requestAnimationFrame(()=>{\n                    // Attempt to check if the bottom bar appeared due to the position change\n                    const bottomBarHeight = innerHeight - window.innerHeight;\n                    if (bottomBarHeight && scrollPos.current >= innerHeight) {\n                        // Move the content further up so that the bottom bar doesn't hide it\n                        document.body.style.top = `${-(scrollPos.current + bottomBarHeight)}px`;\n                    }\n                }), 300);\n        }\n    }, [\n        isOpen\n    ]);\n    const restorePositionSetting = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (previousBodyPosition !== null && !noBodyStyles) {\n            // Convert the position from \"px\" to Int\n            const y = -parseInt(document.body.style.top, 10);\n            const x = -parseInt(document.body.style.left, 10);\n            // Restore styles\n            Object.assign(document.body.style, previousBodyPosition);\n            window.requestAnimationFrame(()=>{\n                if (preventScrollRestoration && activeUrl !== window.location.href) {\n                    setActiveUrl(window.location.href);\n                    return;\n                }\n                window.scrollTo(x, y);\n            });\n            previousBodyPosition = null;\n        }\n    }, [\n        activeUrl\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        function onScroll() {\n            scrollPos.current = window.scrollY;\n        }\n        onScroll();\n        window.addEventListener(\"scroll\", onScroll);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (nested || !hasBeenOpened) return;\n        // This is needed to force Safari toolbar to show **before** the drawer starts animating to prevent a gnarly shift from happening\n        if (isOpen) {\n            // avoid for standalone mode (PWA)\n            const isStandalone = window.matchMedia(\"(display-mode: standalone)\").matches;\n            !isStandalone && setPositionFixed();\n            if (!modal) {\n                window.setTimeout(()=>{\n                    restorePositionSetting();\n                }, 500);\n            }\n        } else {\n            restorePositionSetting();\n        }\n    }, [\n        isOpen,\n        hasBeenOpened,\n        activeUrl,\n        modal,\n        nested,\n        setPositionFixed,\n        restorePositionSetting\n    ]);\n    return {\n        restorePositionSetting\n    };\n}\nconst cache = new WeakMap();\nfunction set(el, styles, ignoreCache = false) {\n    if (!el || !(el instanceof HTMLElement)) return;\n    let originalStyles = {};\n    Object.entries(styles).forEach(([key, value])=>{\n        if (key.startsWith(\"--\")) {\n            el.style.setProperty(key, value);\n            return;\n        }\n        originalStyles[key] = el.style[key];\n        el.style[key] = value;\n    });\n    if (ignoreCache) return;\n    cache.set(el, originalStyles);\n}\nfunction reset(el, prop) {\n    if (!el || !(el instanceof HTMLElement)) return;\n    let originalStyles = cache.get(el);\n    if (!originalStyles) {\n        return;\n    }\n    if (prop) {\n        el.style[prop] = originalStyles[prop];\n    } else {\n        Object.entries(originalStyles).forEach(([key, value])=>{\n            el.style[key] = value;\n        });\n    }\n}\nconst isVertical = (direction)=>{\n    switch(direction){\n        case \"top\":\n        case \"bottom\":\n            return true;\n        case \"left\":\n        case \"right\":\n            return false;\n        default:\n            return direction;\n    }\n};\nfunction getTranslate(element, direction) {\n    if (!element) {\n        return null;\n    }\n    const style = window.getComputedStyle(element);\n    const transform = style.transform || style.webkitTransform || style.mozTransform;\n    let mat = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (mat) {\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n        return parseFloat(mat[1].split(\", \")[isVertical(direction) ? 13 : 12]);\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    mat = transform.match(/^matrix\\((.+)\\)$/);\n    return mat ? parseFloat(mat[1].split(\", \")[isVertical(direction) ? 5 : 4]) : null;\n}\nfunction dampenValue(v) {\n    return 8 * (Math.log(v + 1) - 2);\n}\nconst TRANSITIONS = {\n    DURATION: 0.5,\n    EASE: [\n        0.32,\n        0.72,\n        0,\n        1\n    ]\n};\nconst VELOCITY_THRESHOLD = 0.4;\n// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\nfunction useCallbackRef(callback) {\n    const callbackRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(callback);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        callbackRef.current = callback;\n    });\n    // https://github.com/facebook/react/issues/19240\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(...args)=>callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);\n}\nfunction useUncontrolledState({ defaultProp, onChange }) {\n    const uncontrolledState = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultProp);\n    const [value] = uncontrolledState;\n    const prevValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    const handleChange = useCallbackRef(onChange);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (prevValueRef.current !== value) {\n            handleChange(value);\n            prevValueRef.current = value;\n        }\n    }, [\n        value,\n        prevValueRef,\n        handleChange\n    ]);\n    return uncontrolledState;\n}\nfunction useControllableState({ prop, defaultProp, onChange = ()=>{} }) {\n    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\n        defaultProp,\n        onChange\n    });\n    const isControlled = prop !== undefined;\n    const value = isControlled ? prop : uncontrolledProp;\n    const handleChange = useCallbackRef(onChange);\n    const setValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextValue)=>{\n        if (isControlled) {\n            const setter = nextValue;\n            const value = typeof nextValue === \"function\" ? setter(prop) : nextValue;\n            if (value !== prop) handleChange(value);\n        } else {\n            setUncontrolledProp(nextValue);\n        }\n    }, [\n        isControlled,\n        prop,\n        setUncontrolledProp,\n        handleChange\n    ]);\n    return [\n        value,\n        setValue\n    ];\n}\nfunction useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints, drawerRef, overlayRef, fadeFromIndex, onSnapPointChange, direction = \"bottom\" }) {\n    const [activeSnapPoint, setActiveSnapPoint] = useControllableState({\n        prop: activeSnapPointProp,\n        defaultProp: snapPoints == null ? void 0 : snapPoints[0],\n        onChange: setActiveSnapPointProp\n    });\n    const isLastSnapPoint = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;\n    const activeSnapPointIndex = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPoint), [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const snapPointsOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        var _snapPoints_map;\n        return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map((snapPoint)=>{\n            const hasWindow = \"undefined\" !== \"undefined\";\n            const isPx = typeof snapPoint === \"string\";\n            let snapPointAsNumber = 0;\n            if (isPx) {\n                snapPointAsNumber = parseInt(snapPoint, 10);\n            }\n            if (isVertical(direction)) {\n                const height = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerHeight : 0;\n                if (hasWindow) {\n                    return direction === \"bottom\" ? window.innerHeight - height : -window.innerHeight + height;\n                }\n                return height;\n            }\n            const width = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerWidth : 0;\n            if (hasWindow) {\n                return direction === \"right\" ? window.innerWidth - width : -window.innerWidth + width;\n            }\n            return width;\n        })) != null ? _snapPoints_map : [];\n    }, [\n        snapPoints\n    ]);\n    const activeSnapPointOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [\n        snapPointsOffset,\n        activeSnapPointIndex\n    ]);\n    const snapToPoint = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((dimension)=>{\n        var _snapPointsOffset_findIndex;\n        const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex((snapPointDim)=>snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;\n        onSnapPointChange(newSnapPointIndex);\n        set(drawerRef.current, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            transform: isVertical(direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`\n        });\n        if (snapPointsOffset && newSnapPointIndex !== snapPointsOffset.length - 1 && newSnapPointIndex !== fadeFromIndex) {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                opacity: \"0\"\n            });\n        } else {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                opacity: \"1\"\n            });\n        }\n        setActiveSnapPoint(newSnapPointIndex !== null ? snapPoints == null ? void 0 : snapPoints[newSnapPointIndex] : null);\n    }, [\n        drawerRef.current,\n        snapPoints,\n        snapPointsOffset,\n        fadeFromIndex,\n        overlayRef,\n        setActiveSnapPoint\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (activeSnapPoint || activeSnapPointProp) {\n            var _snapPoints_findIndex;\n            const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPointProp || snapPoint === activeSnapPoint)) != null ? _snapPoints_findIndex : -1;\n            if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === \"number\") {\n                snapToPoint(snapPointsOffset[newIndex]);\n            }\n        }\n    }, [\n        activeSnapPoint,\n        activeSnapPointProp,\n        snapPoints,\n        snapPointsOffset,\n        snapToPoint\n    ]);\n    function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {\n        if (fadeFromIndex === undefined) return;\n        const currentPosition = direction === \"bottom\" || direction === \"right\" ? (activeSnapPointOffset != null ? activeSnapPointOffset : 0) - draggedDistance : (activeSnapPointOffset != null ? activeSnapPointOffset : 0) + draggedDistance;\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isFirst = activeSnapPointIndex === 0;\n        const hasDraggedUp = draggedDistance > 0;\n        if (isOverlaySnapPoint) {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            });\n        }\n        if (velocity > 2 && !hasDraggedUp) {\n            if (dismissible) closeDrawer();\n            else snapToPoint(snapPointsOffset[0]); // snap to initial point\n            return;\n        }\n        if (velocity > 2 && hasDraggedUp && snapPointsOffset && snapPoints) {\n            snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n            return;\n        }\n        // Find the closest snap point to the current position\n        const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr)=>{\n            if (typeof prev !== \"number\" || typeof curr !== \"number\") return prev;\n            return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;\n        });\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {\n            const dragDirection = hasDraggedUp ? 1 : -1; // 1 = up, -1 = down\n            // Don't do anything if we swipe upwards while being on the last snap point\n            if (dragDirection > 0 && isLastSnapPoint) {\n                snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n                return;\n            }\n            if (isFirst && dragDirection < 0 && dismissible) {\n                closeDrawer();\n            }\n            if (activeSnapPointIndex === null) return;\n            snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);\n            return;\n        }\n        snapToPoint(closestSnapPoint);\n    }\n    function onDrag({ draggedDistance }) {\n        if (activeSnapPointOffset === null) return;\n        const newValue = direction === \"bottom\" || direction === \"right\" ? activeSnapPointOffset - draggedDistance : activeSnapPointOffset + draggedDistance;\n        // Don't do anything if we exceed the last(biggest) snap point\n        if ((direction === \"bottom\" || direction === \"right\") && newValue < snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        if ((direction === \"top\" || direction === \"left\") && newValue > snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`\n        });\n    }\n    function getPercentageDragged(absDraggedDistance, isDraggingDown) {\n        if (!snapPoints || typeof activeSnapPointIndex !== \"number\" || !snapPointsOffset || fadeFromIndex === undefined) return null;\n        // If this is true we are dragging to a snap point that is supposed to have an overlay\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex;\n        if (isOverlaySnapPointOrHigher && isDraggingDown) {\n            return 0;\n        }\n        // Don't animate, but still use this one if we are dragging away from the overlaySnapPoint\n        if (isOverlaySnapPoint && !isDraggingDown) return 1;\n        if (!shouldFade && !isOverlaySnapPoint) return null;\n        // Either fadeFrom index or the one before\n        const targetSnapPointIndex = isOverlaySnapPoint ? activeSnapPointIndex + 1 : activeSnapPointIndex - 1;\n        // Get the distance from overlaySnapPoint to the one before or vice-versa to calculate the opacity percentage accordingly\n        const snapPointDistance = isOverlaySnapPoint ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1] : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];\n        const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);\n        if (isOverlaySnapPoint) {\n            return 1 - percentageDragged;\n        } else {\n            return percentageDragged;\n        }\n    }\n    return {\n        isLastSnapPoint,\n        activeSnapPoint,\n        shouldFade,\n        getPercentageDragged,\n        setActiveSnapPoint,\n        activeSnapPointIndex,\n        onRelease,\n        onDrag,\n        snapPointsOffset\n    };\n}\nconst CLOSE_THRESHOLD = 0.25;\nconst SCROLL_LOCK_TIMEOUT = 100;\nconst BORDER_RADIUS = 8;\nconst NESTED_DISPLACEMENT = 16;\nconst WINDOW_TOP_OFFSET = 26;\nconst DRAG_CLASS = \"vaul-dragging\";\nfunction Root({ open: openProp, onOpenChange, children, shouldScaleBackground, onDrag: onDragProp, onRelease: onReleaseProp, snapPoints, nested = false, setBackgroundColorOnScale = true, closeThreshold = CLOSE_THRESHOLD, scrollLockTimeout = SCROLL_LOCK_TIMEOUT, dismissible = true, handleOnly = false, fadeFromIndex = snapPoints && snapPoints.length - 1, activeSnapPoint: activeSnapPointProp, setActiveSnapPoint: setActiveSnapPointProp, fixed, modal = true, onClose, noBodyStyles, direction = \"bottom\", preventScrollRestoration = true, disablePreventScroll = false }) {\n    var _drawerRef_current;\n    const [isOpen = false, setIsOpen] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [hasBeenOpened, setHasBeenOpened] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    // Not visible = translateY(100%)\n    const [visible, setVisible] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isDragging, setIsDragging] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [justReleased, setJustReleased] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const overlayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const openTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dragStartTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dragEndTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const lastTimeDragPrevented = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isAllowedToDrag = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const nestedOpenChangeTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const pointerStart = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const keyboardIsOpen = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const previousDiffFromInitial = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const drawerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const drawerHeightRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);\n    const initialDrawerHeight = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const onSnapPointChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((activeSnapPointIndex)=>{\n        // Change openTime ref when we reach the last snap point to prevent dragging for 500ms incase it's scrollable.\n        if (snapPoints && activeSnapPointIndex === snapPointsOffset.length - 1) openTime.current = new Date();\n    }, []);\n    const { activeSnapPoint, activeSnapPointIndex, setActiveSnapPoint, onRelease: onReleaseSnapPoints, snapPointsOffset, onDrag: onDragSnapPoints, shouldFade, getPercentageDragged: getSnapPointsPercentageDragged } = useSnapPoints({\n        snapPoints,\n        activeSnapPointProp,\n        setActiveSnapPointProp,\n        drawerRef,\n        fadeFromIndex,\n        overlayRef,\n        onSnapPointChange,\n        direction\n    });\n    usePreventScroll({\n        isDisabled: !isOpen || isDragging || !modal || justReleased || !hasBeenOpened || disablePreventScroll\n    });\n    const { restorePositionSetting } = usePositionFixed({\n        isOpen,\n        modal,\n        nested,\n        hasBeenOpened,\n        preventScrollRestoration,\n        noBodyStyles\n    });\n    function getScale() {\n        return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n    }\n    function onPress(event) {\n        var _drawerRef_current;\n        if (!dismissible && !snapPoints) return;\n        if (drawerRef.current && !drawerRef.current.contains(event.target)) return;\n        drawerHeightRef.current = ((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0;\n        setIsDragging(true);\n        dragStartTime.current = new Date();\n        // iOS doesn't trigger mouseUp after scrolling so we need to listen to touched in order to disallow dragging\n        if (isIOS()) {\n            window.addEventListener(\"touchend\", ()=>isAllowedToDrag.current = false, {\n                once: true\n            });\n        }\n        // Ensure we maintain correct pointer capture even when going outside of the drawer\n        event.target.setPointerCapture(event.pointerId);\n        pointerStart.current = isVertical(direction) ? event.clientY : event.clientX;\n    }\n    function shouldDrag(el, isDraggingInDirection) {\n        var _window_getSelection;\n        let element = el;\n        const highlightedText = (_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString();\n        const swipeAmount = drawerRef.current ? getTranslate(drawerRef.current, direction) : null;\n        const date = new Date();\n        if (element.hasAttribute(\"data-vaul-no-drag\") || element.closest(\"[data-vaul-no-drag]\")) {\n            return false;\n        }\n        if (direction === \"right\" || direction === \"left\") {\n            return true;\n        }\n        // Allow scrolling when animating\n        if (openTime.current && date.getTime() - openTime.current.getTime() < 500) {\n            return false;\n        }\n        if (swipeAmount !== null) {\n            if (direction === \"bottom\" ? swipeAmount > 0 : swipeAmount < 0) {\n                return true;\n            }\n        }\n        // Don't drag if there's highlighted text\n        if (highlightedText && highlightedText.length > 0) {\n            return false;\n        }\n        // Disallow dragging if drawer was scrolled within `scrollLockTimeout`\n        if (lastTimeDragPrevented.current && date.getTime() - lastTimeDragPrevented.current.getTime() < scrollLockTimeout && swipeAmount === 0) {\n            lastTimeDragPrevented.current = date;\n            return false;\n        }\n        if (isDraggingInDirection) {\n            lastTimeDragPrevented.current = date;\n            // We are dragging down so we should allow scrolling\n            return false;\n        }\n        // Keep climbing up the DOM tree as long as there's a parent\n        while(element){\n            // Check if the element is scrollable\n            if (element.scrollHeight > element.clientHeight) {\n                if (element.scrollTop !== 0) {\n                    lastTimeDragPrevented.current = new Date();\n                    // The element is scrollable and not scrolled to the top, so don't drag\n                    return false;\n                }\n                if (element.getAttribute(\"role\") === \"dialog\") {\n                    return true;\n                }\n            }\n            // Move up to the parent element\n            element = element.parentNode;\n        }\n        // No scrollable parents not scrolled to the top found, so drag\n        return true;\n    }\n    function onDrag(event) {\n        if (!drawerRef.current) {\n            return;\n        }\n        // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n        if (isDragging) {\n            const directionMultiplier = direction === \"bottom\" || direction === \"right\" ? 1 : -1;\n            const draggedDistance = (pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX)) * directionMultiplier;\n            const isDraggingInDirection = draggedDistance > 0;\n            // Pre condition for disallowing dragging in the close direction.\n            const noCloseSnapPointsPreCondition = snapPoints && !dismissible && !isDraggingInDirection;\n            // Disallow dragging down to close when first snap point is the active one and dismissible prop is set to false.\n            if (noCloseSnapPointsPreCondition && activeSnapPointIndex === 0) return;\n            // We need to capture last time when drag with scroll was triggered and have a timeout between\n            const absDraggedDistance = Math.abs(draggedDistance);\n            const wrapper = document.querySelector(\"[vaul-drawer-wrapper]\");\n            // Calculate the percentage dragged, where 1 is the closed position\n            let percentageDragged = absDraggedDistance / drawerHeightRef.current;\n            const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);\n            if (snapPointPercentageDragged !== null) {\n                percentageDragged = snapPointPercentageDragged;\n            }\n            // Disallow close dragging beyond the smallest snap point.\n            if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {\n                return;\n            }\n            if (!isAllowedToDrag.current && !shouldDrag(event.target, isDraggingInDirection)) return;\n            drawerRef.current.classList.add(DRAG_CLASS);\n            // If shouldDrag gave true once after pressing down on the drawer, we set isAllowedToDrag to true and it will remain true until we let go, there's no reason to disable dragging mid way, ever, and that's the solution to it\n            isAllowedToDrag.current = true;\n            set(drawerRef.current, {\n                transition: \"none\"\n            });\n            set(overlayRef.current, {\n                transition: \"none\"\n            });\n            if (snapPoints) {\n                onDragSnapPoints({\n                    draggedDistance\n                });\n            }\n            // Run this only if snapPoints are not defined or if we are at the last snap point (highest one)\n            if (isDraggingInDirection && !snapPoints) {\n                const dampenedDraggedDistance = dampenValue(draggedDistance);\n                const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n                return;\n            }\n            const opacityValue = 1 - percentageDragged;\n            if (shouldFade || fadeFromIndex && activeSnapPointIndex === fadeFromIndex - 1) {\n                onDragProp == null ? void 0 : onDragProp(event, percentageDragged);\n                set(overlayRef.current, {\n                    opacity: `${opacityValue}`,\n                    transition: \"none\"\n                }, true);\n            }\n            if (wrapper && overlayRef.current && shouldScaleBackground) {\n                // Calculate percentageDragged as a fraction (0 to 1)\n                const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n                const borderRadiusValue = 8 - percentageDragged * 8;\n                const translateValue = Math.max(0, 14 - percentageDragged * 14);\n                set(wrapper, {\n                    borderRadius: `${borderRadiusValue}px`,\n                    transform: isVertical(direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,\n                    transition: \"none\"\n                }, true);\n            }\n            if (!snapPoints) {\n                const translateValue = absDraggedDistance * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }\n        }\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            scaleBackground(false);\n            restorePositionSetting();\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _window_visualViewport;\n        function onVisualViewportChange() {\n            if (!drawerRef.current) return;\n            const focusedElement = document.activeElement;\n            if (isInput(focusedElement) || keyboardIsOpen.current) {\n                var _window_visualViewport;\n                const visualViewportHeight = ((_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.height) || 0;\n                // This is the height of the keyboard\n                let diffFromInitial = window.innerHeight - visualViewportHeight;\n                const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;\n                if (!initialDrawerHeight.current) {\n                    initialDrawerHeight.current = drawerHeight;\n                }\n                const offsetFromTop = drawerRef.current.getBoundingClientRect().top;\n                // visualViewport height may change due to some subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.\n                if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {\n                    keyboardIsOpen.current = !keyboardIsOpen.current;\n                }\n                if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {\n                    const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;\n                    diffFromInitial += activeSnapPointHeight;\n                }\n                previousDiffFromInitial.current = diffFromInitial;\n                // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view\n                if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {\n                    const height = drawerRef.current.getBoundingClientRect().height;\n                    let newDrawerHeight = height;\n                    if (height > visualViewportHeight) {\n                        newDrawerHeight = visualViewportHeight - WINDOW_TOP_OFFSET;\n                    }\n                    // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open\n                    if (fixed) {\n                        drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;\n                    } else {\n                        drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;\n                    }\n                } else {\n                    drawerRef.current.style.height = `${initialDrawerHeight.current}px`;\n                }\n                if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {\n                    drawerRef.current.style.bottom = `0px`;\n                } else {\n                    // Negative bottom value would never make sense\n                    drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;\n                }\n            }\n        }\n        (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener(\"resize\", onVisualViewportChange);\n        return ()=>{\n            var _window_visualViewport;\n            return (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.removeEventListener(\"resize\", onVisualViewportChange);\n        };\n    }, [\n        activeSnapPointIndex,\n        snapPoints,\n        snapPointsOffset\n    ]);\n    function closeDrawer() {\n        if (!drawerRef.current) return;\n        cancelDrag();\n        onClose == null ? void 0 : onClose();\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `translate3d(0, ${direction === \"bottom\" ? \"100%\" : \"-100%\"}, 0)` : `translate3d(${direction === \"right\" ? \"100%\" : \"-100%\"}, 0, 0)`,\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n        });\n        set(overlayRef.current, {\n            opacity: \"0\",\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n        });\n        scaleBackground(false);\n        setTimeout(()=>{\n            setVisible(false);\n            setIsOpen(false);\n        }, 300);\n        setTimeout(()=>{\n            // reset(document.documentElement, 'scrollBehavior');\n            if (snapPoints) {\n                setActiveSnapPoint(snapPoints[0]);\n            }\n        }, TRANSITIONS.DURATION * 1000); // seconds to ms\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!isOpen && shouldScaleBackground) {\n            // Can't use `onAnimationEnd` as the component will be invisible by then\n            const id = setTimeout(()=>{\n                reset(document.body);\n            }, 200);\n            return ()=>clearTimeout(id);\n        }\n    }, [\n        isOpen,\n        shouldScaleBackground\n    ]);\n    // LayoutEffect to prevent extra render where openProp and isOpen are not synced yet\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        if (openProp) {\n            setIsOpen(true);\n            setHasBeenOpened(true);\n        } else {\n            closeDrawer();\n        }\n    }, [\n        openProp\n    ]);\n    // This can be done much better\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (mounted) {\n            onOpenChange == null ? void 0 : onOpenChange(isOpen);\n        }\n    }, [\n        isOpen\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    function resetDrawer() {\n        if (!drawerRef.current) return;\n        const wrapper = document.querySelector(\"[vaul-drawer-wrapper]\");\n        const currentSwipeAmount = getTranslate(drawerRef.current, direction);\n        set(drawerRef.current, {\n            transform: \"translate3d(0, 0, 0)\",\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n        });\n        set(overlayRef.current, {\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            opacity: \"1\"\n        });\n        // Don't reset background if swiped upwards\n        if (shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && isOpen) {\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: \"hidden\",\n                ...isVertical(direction) ? {\n                    transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    transformOrigin: \"top\"\n                } : {\n                    transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    transformOrigin: \"left\"\n                },\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            }, true);\n        }\n    }\n    function cancelDrag() {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n    }\n    function onRelease(event) {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n        const swipeAmount = getTranslate(drawerRef.current, direction);\n        if (!shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) return;\n        if (dragStartTime.current === null) return;\n        const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();\n        const distMoved = pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX);\n        const velocity = Math.abs(distMoved) / timeTaken;\n        if (velocity > 0.05) {\n            // `justReleased` is needed to prevent the drawer from focusing on an input when the drag ends, as it's not the intent most of the time.\n            setJustReleased(true);\n            setTimeout(()=>{\n                setJustReleased(false);\n            }, 200);\n        }\n        if (snapPoints) {\n            const directionMultiplier = direction === \"bottom\" || direction === \"right\" ? 1 : -1;\n            onReleaseSnapPoints({\n                draggedDistance: distMoved * directionMultiplier,\n                closeDrawer,\n                velocity,\n                dismissible\n            });\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        // Moved upwards, don't do anything\n        if (direction === \"bottom\" || direction === \"right\" ? distMoved > 0 : distMoved < 0) {\n            resetDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        if (velocity > VELOCITY_THRESHOLD) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        var _drawerRef_current_getBoundingClientRect_height;\n        const visibleDrawerHeight = Math.min((_drawerRef_current_getBoundingClientRect_height = drawerRef.current.getBoundingClientRect().height) != null ? _drawerRef_current_getBoundingClientRect_height : 0, window.innerHeight);\n        if (swipeAmount >= visibleDrawerHeight * closeThreshold) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n        resetDrawer();\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Trigger enter animation without using CSS animation\n        if (isOpen) {\n            set(document.documentElement, {\n                scrollBehavior: \"auto\"\n            });\n            openTime.current = new Date();\n            scaleBackground(true);\n        }\n    }, [\n        isOpen\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (drawerRef.current && visible) {\n            var _drawerRef_current;\n            // Find all scrollable elements inside our drawer and assign a class to it so that we can disable overflow when dragging to prevent pointermove not being captured\n            const children = drawerRef == null ? void 0 : (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.querySelectorAll(\"*\");\n            children == null ? void 0 : children.forEach((child)=>{\n                const htmlChild = child;\n                if (htmlChild.scrollHeight > htmlChild.clientHeight || htmlChild.scrollWidth > htmlChild.clientWidth) {\n                    htmlChild.classList.add(\"vaul-scrollable\");\n                }\n            });\n        }\n    }, [\n        visible\n    ]);\n    function scaleBackground(open) {\n        const wrapper = document.querySelector(\"[vaul-drawer-wrapper]\");\n        if (!wrapper || !shouldScaleBackground) return;\n        if (open) {\n            if (setBackgroundColorOnScale) {\n                if (!noBodyStyles) {\n                    // setting original styles initially\n                    set(document.body, {\n                        background: document.body.style.backgroundColor || document.body.style.background\n                    });\n                    // setting body styles, with cache ignored, so that we can get correct original styles in reset\n                    set(document.body, {\n                        background: \"black\"\n                    }, true);\n                }\n            }\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: \"hidden\",\n                ...isVertical(direction) ? {\n                    transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    transformOrigin: \"top\"\n                } : {\n                    transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    transformOrigin: \"left\"\n                },\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            });\n        } else {\n            // Exit\n            reset(wrapper, \"overflow\");\n            reset(wrapper, \"transform\");\n            reset(wrapper, \"borderRadius\");\n            set(wrapper, {\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            });\n        }\n    }\n    function onNestedOpenChange(o) {\n        const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;\n        const y = o ? -NESTED_DISPLACEMENT : 0;\n        if (nestedOpenChangeTimer.current) {\n            window.clearTimeout(nestedOpenChangeTimer.current);\n        }\n        set(drawerRef.current, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            transform: `scale(${scale}) translate3d(0, ${y}px, 0)`\n        });\n        if (!o && drawerRef.current) {\n            nestedOpenChangeTimer.current = setTimeout(()=>{\n                const translateValue = getTranslate(drawerRef.current, direction);\n                set(drawerRef.current, {\n                    transition: \"none\",\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }, 500);\n        }\n    }\n    function onNestedDrag(event, percentageDragged) {\n        if (percentageDragged < 0) return;\n        const initialDim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        const initialScale = (initialDim - NESTED_DISPLACEMENT) / initialDim;\n        const newScale = initialScale + percentageDragged * (1 - initialScale);\n        const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,\n            transition: \"none\"\n        });\n    }\n    function onNestedRelease(event, o) {\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;\n        const translate = o ? -NESTED_DISPLACEMENT : 0;\n        if (o) {\n            set(drawerRef.current, {\n                transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`\n            });\n        }\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Root, {\n        modal: modal,\n        onOpenChange: (o)=>{\n            if (openProp !== undefined) {\n                onOpenChange == null ? void 0 : onOpenChange(o);\n                return;\n            }\n            if (!o) {\n                closeDrawer();\n            } else {\n                setHasBeenOpened(true);\n                setIsOpen(o);\n            }\n        },\n        open: isOpen\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DrawerContext.Provider, {\n        value: {\n            visible,\n            activeSnapPoint,\n            snapPoints,\n            setActiveSnapPoint,\n            drawerRef,\n            overlayRef,\n            scaleBackground,\n            onOpenChange,\n            onPress,\n            setVisible,\n            onRelease,\n            onDrag,\n            dismissible,\n            handleOnly,\n            isOpen,\n            isDragging,\n            shouldFade,\n            closeDrawer,\n            onNestedDrag,\n            onNestedOpenChange,\n            onNestedRelease,\n            keyboardIsOpen,\n            openProp,\n            modal,\n            snapPointsOffset,\n            direction\n        }\n    }, children));\n}\nconst LONG_HANDLE_PRESS_TIMEOUT = 250;\nconst DOUBLE_TAP_TIMEOUT = 120;\nconst Handle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ preventCycle = false, children, ...rest }, ref) {\n    const { visible, closeDrawer, isDragging, snapPoints, activeSnapPoint, setActiveSnapPoint, dismissible, handleOnly, onPress, onDrag } = useDrawerContext();\n    const closeTimeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const shouldCancelInteractionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    function handleStartCycle() {\n        // Stop if this is the second click of a double click\n        if (shouldCancelInteractionRef.current) {\n            handleCancelInteraction();\n            return;\n        }\n        window.setTimeout(()=>{\n            handleCycleSnapPoints();\n        }, DOUBLE_TAP_TIMEOUT);\n    }\n    function handleCycleSnapPoints() {\n        // Prevent accidental taps while resizing drawer\n        if (isDragging || preventCycle || shouldCancelInteractionRef.current) {\n            handleCancelInteraction();\n            return;\n        }\n        // Make sure to clear the timeout id if the user releases the handle before the cancel timeout\n        handleCancelInteraction();\n        if ((!snapPoints || snapPoints.length === 0) && dismissible) {\n            closeDrawer();\n            return;\n        }\n        const isLastSnapPoint = activeSnapPoint === snapPoints[snapPoints.length - 1];\n        if (isLastSnapPoint && dismissible) {\n            closeDrawer();\n            return;\n        }\n        const currentSnapIndex = snapPoints.findIndex((point)=>point === activeSnapPoint);\n        if (currentSnapIndex === -1) return; // activeSnapPoint not found in snapPoints\n        const nextSnapPoint = snapPoints[currentSnapIndex + 1];\n        setActiveSnapPoint(nextSnapPoint);\n    }\n    function handleStartInteraction() {\n        closeTimeoutIdRef.current = window.setTimeout(()=>{\n            // Cancel click interaction on a long press\n            shouldCancelInteractionRef.current = true;\n        }, LONG_HANDLE_PRESS_TIMEOUT);\n    }\n    function handleCancelInteraction() {\n        window.clearTimeout(closeTimeoutIdRef.current);\n        shouldCancelInteractionRef.current = false;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        onClick: handleStartCycle,\n        onDoubleClick: ()=>{\n            shouldCancelInteractionRef.current = true;\n            closeDrawer();\n        },\n        onPointerCancel: handleCancelInteraction,\n        onPointerDown: (e)=>{\n            if (handleOnly) onPress(e);\n            handleStartInteraction();\n        },\n        onPointerMove: (e)=>{\n            if (handleOnly) onDrag(e);\n        },\n        // onPointerUp is already handled by the content component\n        ref: ref,\n        \"vaul-drawer-visible\": visible ? \"true\" : \"false\",\n        \"vaul-handle\": \"\",\n        \"aria-hidden\": \"true\",\n        ...rest\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"vaul-handle-hitarea\": \"\",\n        \"aria-hidden\": \"true\"\n    }, children));\n});\nHandle.displayName = \"Drawer.Handle\";\nconst Overlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ children, ...rest }, ref) {\n    const { overlayRef, snapPoints, onRelease, shouldFade, isOpen, visible } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, overlayRef);\n    const hasSnapPoints = snapPoints && snapPoints.length > 0;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Overlay, {\n        onMouseUp: onRelease,\n        ref: composedRef,\n        \"vaul-drawer-visible\": visible ? \"true\" : \"false\",\n        \"vaul-overlay\": \"\",\n        \"vaul-snap-points\": isOpen && hasSnapPoints ? \"true\" : \"false\",\n        \"vaul-snap-points-overlay\": isOpen && shouldFade ? \"true\" : \"false\",\n        ...rest\n    });\n});\nOverlay.displayName = \"Drawer.Overlay\";\nconst Content = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ onOpenAutoFocus, onPointerDownOutside, onAnimationEnd, style, ...rest }, ref) {\n    const { drawerRef, onPress, onRelease, onDrag, dismissible, keyboardIsOpen, snapPointsOffset, visible, closeDrawer, modal, openProp, onOpenChange, setVisible, handleOnly, direction } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, drawerRef);\n    const pointerStartRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const wasBeyondThePointRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isDeltaInDirection = (delta, direction, threshold = 0)=>{\n        if (wasBeyondThePointRef.current) return true;\n        const deltaY = Math.abs(delta.y);\n        const deltaX = Math.abs(delta.x);\n        const isDeltaX = deltaX > deltaY;\n        const dFactor = [\n            \"bottom\",\n            \"right\"\n        ].includes(direction) ? 1 : -1;\n        if (direction === \"left\" || direction === \"right\") {\n            const isReverseDirection = delta.x * dFactor < 0;\n            if (!isReverseDirection && deltaX >= 0 && deltaX <= threshold) {\n                return isDeltaX;\n            }\n        } else {\n            const isReverseDirection = delta.y * dFactor < 0;\n            if (!isReverseDirection && deltaY >= 0 && deltaY <= threshold) {\n                return !isDeltaX;\n            }\n        }\n        wasBeyondThePointRef.current = true;\n        return true;\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Trigger enter animation without using CSS animation\n        setVisible(true);\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Content, {\n        \"vaul-drawer\": \"\",\n        \"vaul-drawer-direction\": direction,\n        \"vaul-drawer-visible\": visible ? \"true\" : \"false\",\n        ...rest,\n        ref: composedRef,\n        style: snapPointsOffset && snapPointsOffset.length > 0 ? {\n            \"--snap-point-height\": `${snapPointsOffset[0]}px`,\n            ...style\n        } : style,\n        onOpenAutoFocus: (e)=>{\n            if (onOpenAutoFocus) {\n                onOpenAutoFocus(e);\n            } else {\n                var _drawerRef_current;\n                e.preventDefault();\n                (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.focus();\n            }\n        },\n        onPointerDown: (event)=>{\n            if (handleOnly) return;\n            rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);\n            pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n            };\n            onPress(event);\n        },\n        onPointerDownOutside: (e)=>{\n            onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);\n            if (!modal || e.defaultPrevented) {\n                e.preventDefault();\n                return;\n            }\n            if (keyboardIsOpen.current) {\n                keyboardIsOpen.current = false;\n            }\n            e.preventDefault();\n            onOpenChange == null ? void 0 : onOpenChange(false);\n            if (!dismissible || openProp !== undefined) {\n                return;\n            }\n            closeDrawer();\n        },\n        onFocusOutside: (e)=>{\n            if (!modal) {\n                e.preventDefault();\n                return;\n            }\n        },\n        onEscapeKeyDown: (e)=>{\n            if (!modal) {\n                e.preventDefault();\n                return;\n            }\n        },\n        onPointerMove: (event)=>{\n            if (handleOnly) return;\n            rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);\n            if (!pointerStartRef.current) return;\n            const yPosition = event.clientY - pointerStartRef.current.y;\n            const xPosition = event.clientX - pointerStartRef.current.x;\n            const swipeStartThreshold = event.pointerType === \"touch\" ? 10 : 2;\n            const delta = {\n                x: xPosition,\n                y: yPosition\n            };\n            const isAllowedToSwipe = isDeltaInDirection(delta, direction, swipeStartThreshold);\n            if (isAllowedToSwipe) onDrag(event);\n            else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {\n                pointerStartRef.current = null;\n            }\n        },\n        onPointerUp: (event)=>{\n            rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);\n            pointerStartRef.current = null;\n            wasBeyondThePointRef.current = false;\n            onRelease(event);\n        }\n    });\n});\nContent.displayName = \"Drawer.Content\";\nfunction NestedRoot({ onDrag, onOpenChange, ...rest }) {\n    const { onNestedDrag, onNestedOpenChange, onNestedRelease } = useDrawerContext();\n    if (!onNestedDrag) {\n        throw new Error(\"Drawer.NestedRoot must be placed in another drawer\");\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Root, {\n        nested: true,\n        onClose: ()=>{\n            onNestedOpenChange(false);\n        },\n        onDrag: (e, p)=>{\n            onNestedDrag(e, p);\n            onDrag == null ? void 0 : onDrag(e, p);\n        },\n        onOpenChange: (o)=>{\n            if (o) {\n                onNestedOpenChange(o);\n            }\n            onOpenChange == null ? void 0 : onOpenChange(o);\n        },\n        onRelease: onNestedRelease,\n        ...rest\n    });\n}\nconst Drawer = {\n    Root,\n    NestedRoot,\n    Content,\n    Handle,\n    Overlay,\n    Trigger: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Trigger,\n    Portal: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Portal,\n    Close: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Close,\n    Title: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Title,\n    Description: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Description\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdmF1bEAwLjkuMV9AdHlwZXMrcmVhY3QtZG9tQDE4LjMuMF9AdHlwZXMrcmVhY3RAMTguMy4zX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3ZhdWwvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OzREQUNBLFNBQVNBLFlBQVlDLElBQUk7SUFDdkIsSUFBSSxDQUFDQSxRQUFRLE9BQU9DLFlBQVksYUFBYTtJQUM3QyxJQUFJQyxPQUFPRCxTQUFTQyxJQUFJLElBQUlELFNBQVNFLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ3BFLElBQUlDLFFBQVFILFNBQVNJLGFBQWEsQ0FBQztJQUNuQ0QsTUFBTUUsSUFBSSxHQUFHO0lBQ2JKLEtBQUtLLFdBQVcsQ0FBQ0g7SUFDaEJBLE1BQU1JLFVBQVUsR0FBSUosTUFBTUksVUFBVSxDQUFDQyxPQUFPLEdBQUdULE9BQVFJLE1BQU1HLFdBQVcsQ0FBQ04sU0FBU1MsY0FBYyxDQUFDVjtBQUNwRztBQUUwRDtBQUMzQjtBQUNvQztBQUVuRSxNQUFNZ0IsOEJBQWdCSCxnREFBNEIsQ0FBQztJQUMvQ0ssV0FBVztRQUNQQyxTQUFTO0lBQ2I7SUFDQUMsWUFBWTtRQUNSRCxTQUFTO0lBQ2I7SUFDQUUsaUJBQWlCLEtBQUs7SUFDdEJDLFNBQVMsS0FBSztJQUNkQyxXQUFXLEtBQUs7SUFDaEJDLFFBQVEsS0FBSztJQUNiQyxjQUFjLEtBQUs7SUFDbkJDLG9CQUFvQixLQUFLO0lBQ3pCQyxpQkFBaUIsS0FBSztJQUN0QkMsVUFBVUM7SUFDVkMsYUFBYTtJQUNiQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUkMsWUFBWTtJQUNaQyxnQkFBZ0I7UUFDWmYsU0FBUztJQUNiO0lBQ0FnQixrQkFBa0I7SUFDbEJDLFlBQVk7SUFDWkMsT0FBTztJQUNQQyxZQUFZO0lBQ1pDLGlCQUFpQjtJQUNqQkMsY0FBYyxLQUFLO0lBQ25CQyxvQkFBb0IsS0FBSztJQUN6QkMsU0FBUztJQUNUQyxhQUFhLEtBQUs7SUFDbEJDLFlBQVksS0FBSztJQUNqQkMsV0FBVztBQUNmO0FBQ0EsTUFBTUMsbUJBQW1CO0lBQ3JCLE1BQU1DLFVBQVVsQyw2Q0FBeUIsQ0FBQ0c7SUFDMUMsSUFBSSxDQUFDK0IsU0FBUztRQUNWLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUNBLE9BQU9GO0FBQ1g7QUFFQWhELFlBQVk7QUFFWixpSUFBaUk7QUFDakksTUFBTW1ELDRCQUE0QixNQUFrQixHQUFjcEMsQ0FBZUEsR0FBR0MsNENBQVNBO0FBQzdGLFNBQVNvQyxNQUFNLEdBQUdDLFNBQVM7SUFDdkIsT0FBTyxDQUFDLEdBQUdDO1FBQ1AsS0FBSyxJQUFJQyxZQUFZRixVQUFVO1lBQzNCLElBQUksT0FBT0UsYUFBYSxZQUFZO2dCQUNoQ0EsWUFBWUQ7WUFDaEI7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTRTtJQUNMLE9BQU9DLGFBQWE7QUFDeEI7QUFDQSxTQUFTQztJQUNMLE9BQU9ELGFBQWE7QUFDeEI7QUFDQSxTQUFTRTtJQUNMLE9BQU9GLGFBQWEsWUFBWSx5RkFBeUY7SUFDekhELFdBQVdJLFVBQVVDLGNBQWMsR0FBRztBQUMxQztBQUNBLFNBQVNDO0lBQ0wsT0FBT0osY0FBY0M7QUFDekI7QUFDQSxTQUFTRixhQUFhTSxFQUFFO0lBQ3BCLE9BQU8sTUFBeUQsR0FBR0EsQ0FBa0MsR0FBR2pDO0FBQzVHO0FBQ0EsYUFBYTtBQUNiLE1BQU1xQyxpQkFBaUIsT0FBT2pFLGFBQWEsZUFBZThELE9BQU9HLGNBQWM7QUFDL0UsU0FBU0MsYUFBYUMsSUFBSTtJQUN0QixJQUFJaEUsUUFBUTJELE9BQU9NLGdCQUFnQixDQUFDRDtJQUNwQyxPQUFPLGdCQUFnQkosSUFBSSxDQUFDNUQsTUFBTWtFLFFBQVEsR0FBR2xFLE1BQU1tRSxTQUFTLEdBQUduRSxNQUFNb0UsU0FBUztBQUNsRjtBQUNBLFNBQVNDLGdCQUFnQkwsSUFBSTtJQUN6QixJQUFJRCxhQUFhQyxPQUFPO1FBQ3BCQSxPQUFPQSxLQUFLTSxhQUFhO0lBQzdCO0lBQ0EsTUFBTU4sUUFBUSxDQUFDRCxhQUFhQyxNQUFNO1FBQzlCQSxPQUFPQSxLQUFLTSxhQUFhO0lBQzdCO0lBQ0EsT0FBT04sUUFBUW5FLFNBQVMwRSxnQkFBZ0IsSUFBSTFFLFNBQVMyRSxlQUFlO0FBQ3hFO0FBQ0Esc0VBQXNFO0FBQ3RFLE1BQU1DLG9CQUFvQixJQUFJQyxJQUFJO0lBQzlCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsbUlBQW1JO0FBQ25JLElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQztBQUNKOzs7O0NBSUMsR0FBRyxTQUFTQyxpQkFBaUJDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLElBQUksRUFBRUMsVUFBVSxFQUFFLEdBQUdEO0lBQ3JCaEMsMEJBQTBCO1FBQ3RCLElBQUlpQyxZQUFZO1lBQ1o7UUFDSjtRQUNBSjtRQUNBLElBQUlBLHVCQUF1QixHQUFHO1lBQzFCLElBQUlsQixTQUFTO2dCQUNUbUIsVUFBVUk7WUFDZCxPQUFPO2dCQUNISixVQUFVSztZQUNkO1FBQ0o7UUFDQSxPQUFPO1lBQ0hOO1lBQ0EsSUFBSUEsdUJBQXVCLEdBQUc7Z0JBQzFCQztZQUNKO1FBQ0o7SUFDSixHQUFHO1FBQ0NHO0tBQ0g7QUFDTDtBQUNBLDBGQUEwRjtBQUMxRixtRkFBbUY7QUFDbkYsU0FBU0U7SUFDTCxPQUFPbEMsTUFBTW1DLFNBQVNyRixTQUFTMkUsZUFBZSxFQUFFLGdCQUFnQixDQUFDLEVBQUViLE9BQU93QixVQUFVLEdBQUd0RixTQUFTMkUsZUFBZSxDQUFDWSxXQUFXLENBQUMsRUFBRSxDQUFDO0FBQ25JO0FBQ0Esd0VBQXdFO0FBQ3hFLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0YsOEZBQThGO0FBQzlGLHNHQUFzRztBQUN0RyxtQ0FBbUM7QUFDbkMsNkdBQTZHO0FBQzdHLDJFQUEyRTtBQUMzRSw0R0FBNEc7QUFDNUcsc0dBQXNHO0FBQ3RHLEVBQUU7QUFDRixvR0FBb0c7QUFDcEcsRUFBRTtBQUNGLCtHQUErRztBQUMvRyxvQkFBb0I7QUFDcEIsMEdBQTBHO0FBQzFHLGtHQUFrRztBQUNsRyx1R0FBdUc7QUFDdkcscUdBQXFHO0FBQ3JHLDRHQUE0RztBQUM1Ryw0REFBNEQ7QUFDNUQsa0hBQWtIO0FBQ2xILDBHQUEwRztBQUMxRyxvRkFBb0Y7QUFDcEYsZ0hBQWdIO0FBQ2hILG9GQUFvRjtBQUNwRixTQUFTSjtJQUNMLElBQUlLO0lBQ0osSUFBSUMsUUFBUTtJQUNaLElBQUlDLGVBQWUsQ0FBQ0M7UUFDaEIsc0ZBQXNGO1FBQ3RGSCxhQUFhaEIsZ0JBQWdCbUIsRUFBRUMsTUFBTTtRQUNyQyxJQUFJSixlQUFleEYsU0FBUzJFLGVBQWUsSUFBSWEsZUFBZXhGLFNBQVM2RixJQUFJLEVBQUU7WUFDekU7UUFDSjtRQUNBSixRQUFRRSxFQUFFRyxjQUFjLENBQUMsRUFBRSxDQUFDQyxLQUFLO0lBQ3JDO0lBQ0EsSUFBSUMsY0FBYyxDQUFDTDtRQUNmLGdDQUFnQztRQUNoQyxJQUFJLENBQUNILGNBQWNBLGVBQWV4RixTQUFTMkUsZUFBZSxJQUFJYSxlQUFleEYsU0FBUzZGLElBQUksRUFBRTtZQUN4RkYsRUFBRU0sY0FBYztZQUNoQjtRQUNKO1FBQ0EsNkVBQTZFO1FBQzdFLDRFQUE0RTtRQUM1RSw0RUFBNEU7UUFDNUUsdUNBQXVDO1FBQ3ZDLElBQUlDLElBQUlQLEVBQUVHLGNBQWMsQ0FBQyxFQUFFLENBQUNDLEtBQUs7UUFDakMsSUFBSUksWUFBWVgsV0FBV1csU0FBUztRQUNwQyxJQUFJQyxTQUFTWixXQUFXYSxZQUFZLEdBQUdiLFdBQVdjLFlBQVk7UUFDOUQsSUFBSUYsV0FBVyxHQUFHO1lBQ2Q7UUFDSjtRQUNBLElBQUlELGFBQWEsS0FBS0QsSUFBSVQsU0FBU1UsYUFBYUMsVUFBVUYsSUFBSVQsT0FBTztZQUNqRUUsRUFBRU0sY0FBYztRQUNwQjtRQUNBUixRQUFRUztJQUNaO0lBQ0EsSUFBSUssYUFBYSxDQUFDWjtRQUNkLElBQUlDLFNBQVNELEVBQUVDLE1BQU07UUFDckIsdUVBQXVFO1FBQ3ZFLElBQUlZLFFBQVFaLFdBQVdBLFdBQVc1RixTQUFTeUcsYUFBYSxFQUFFO1lBQ3REZCxFQUFFTSxjQUFjO1lBQ2hCLHNGQUFzRjtZQUN0RixvRkFBb0Y7WUFDcEYsK0VBQStFO1lBQy9FTCxPQUFPekYsS0FBSyxDQUFDdUcsU0FBUyxHQUFHO1lBQ3pCZCxPQUFPZSxLQUFLO1lBQ1pDLHNCQUFzQjtnQkFDbEJoQixPQUFPekYsS0FBSyxDQUFDdUcsU0FBUyxHQUFHO1lBQzdCO1FBQ0o7SUFDSjtJQUNBLElBQUlHLFVBQVUsQ0FBQ2xCO1FBQ1gsSUFBSUMsU0FBU0QsRUFBRUMsTUFBTTtRQUNyQixJQUFJWSxRQUFRWixTQUFTO1lBQ2pCLG1GQUFtRjtZQUNuRixpRkFBaUY7WUFDakYsd0ZBQXdGO1lBQ3hGLCtGQUErRjtZQUMvRkEsT0FBT3pGLEtBQUssQ0FBQ3VHLFNBQVMsR0FBRztZQUN6QkUsc0JBQXNCO2dCQUNsQmhCLE9BQU96RixLQUFLLENBQUN1RyxTQUFTLEdBQUc7Z0JBQ3pCLHFGQUFxRjtnQkFDckYsd0ZBQXdGO2dCQUN4RixJQUFJekMsZ0JBQWdCO29CQUNoQixJQUFJQSxlQUFlNkMsTUFBTSxHQUFHaEQsT0FBT2lELFdBQVcsRUFBRTt3QkFDNUMseUVBQXlFO3dCQUN6RSwyQ0FBMkM7d0JBQzNDSCxzQkFBc0I7NEJBQ2xCSSxlQUFlcEI7d0JBQ25CO29CQUNKLE9BQU87d0JBQ0gsK0VBQStFO3dCQUMvRSw2Q0FBNkM7d0JBQzdDM0IsZUFBZWdELGdCQUFnQixDQUFDLFVBQVUsSUFBSUQsZUFBZXBCLFNBQVM7NEJBQ2xFc0IsTUFBTTt3QkFDVjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLElBQUlDLGlCQUFpQjtRQUNqQixrRUFBa0U7UUFDbEUsMkZBQTJGO1FBQzNGckQsT0FBT3NELFFBQVEsQ0FBQyxHQUFHO0lBQ3ZCO0lBQ0EsNERBQTREO0lBQzVELDBGQUEwRjtJQUMxRiw2RkFBNkY7SUFDN0YsSUFBSUMsVUFBVXZELE9BQU93RCxXQUFXO0lBQ2hDLElBQUlDLFVBQVV6RCxPQUFPMEQsV0FBVztJQUNoQyxJQUFJQyxnQkFBZ0J2RSxNQUFNbUMsU0FBU3JGLFNBQVMyRSxlQUFlLEVBQUUsZ0JBQWdCLENBQUMsRUFBRWIsT0FBT3dCLFVBQVUsR0FBR3RGLFNBQVMyRSxlQUFlLENBQUNZLFdBQVcsQ0FBQyxFQUFFLENBQUM7SUFDNUkscUZBQXFGO0lBQ3JGekIsT0FBT3NELFFBQVEsQ0FBQyxHQUFHO0lBQ25CLElBQUlNLGVBQWV4RSxNQUFNeUUsU0FBUzNILFVBQVUsY0FBYzBGLGNBQWM7UUFDcEVrQyxTQUFTO1FBQ1RDLFNBQVM7SUFDYixJQUFJRixTQUFTM0gsVUFBVSxhQUFhZ0csYUFBYTtRQUM3QzRCLFNBQVM7UUFDVEMsU0FBUztJQUNiLElBQUlGLFNBQVMzSCxVQUFVLFlBQVl1RyxZQUFZO1FBQzNDcUIsU0FBUztRQUNUQyxTQUFTO0lBQ2IsSUFBSUYsU0FBUzNILFVBQVUsU0FBUzZHLFNBQVMsT0FBT2MsU0FBUzdELFFBQVEsVUFBVXFEO0lBQzNFLE9BQU87UUFDSCwyREFBMkQ7UUFDM0RNO1FBQ0FDO1FBQ0E1RCxPQUFPc0QsUUFBUSxDQUFDQyxTQUFTRTtJQUM3QjtBQUNKO0FBQ0EsZ0dBQWdHO0FBQ2hHLFNBQVNsQyxTQUFTeUMsT0FBTyxFQUFFM0gsS0FBSyxFQUFFNEgsS0FBSztJQUNuQyxJQUFJQyxNQUFNRixRQUFRM0gsS0FBSyxDQUFDQSxNQUFNO0lBQzlCMkgsUUFBUTNILEtBQUssQ0FBQ0EsTUFBTSxHQUFHNEg7SUFDdkIsT0FBTztRQUNIRCxRQUFRM0gsS0FBSyxDQUFDQSxNQUFNLEdBQUc2SDtJQUMzQjtBQUNKO0FBQ0EsNkVBQTZFO0FBQzdFLFNBQVNMLFNBQVMvQixNQUFNLEVBQUVxQyxLQUFLLEVBQUVDLE9BQU8sRUFBRWpELE9BQU87SUFDN0MsYUFBYTtJQUNiVyxPQUFPcUIsZ0JBQWdCLENBQUNnQixPQUFPQyxTQUFTakQ7SUFDeEMsT0FBTztRQUNILGFBQWE7UUFDYlcsT0FBT3VDLG1CQUFtQixDQUFDRixPQUFPQyxTQUFTakQ7SUFDL0M7QUFDSjtBQUNBLFNBQVMrQixlQUFlcEIsTUFBTTtJQUMxQixJQUFJd0MsT0FBT3BJLFNBQVMwRSxnQkFBZ0IsSUFBSTFFLFNBQVMyRSxlQUFlO0lBQ2hFLE1BQU1pQixVQUFVQSxXQUFXd0MsS0FBSztRQUM1QiwwR0FBMEc7UUFDMUcsSUFBSTVDLGFBQWFoQixnQkFBZ0JvQjtRQUNqQyxJQUFJSixlQUFleEYsU0FBUzJFLGVBQWUsSUFBSWEsZUFBZXhGLFNBQVM2RixJQUFJLElBQUlMLGVBQWVJLFFBQVE7WUFDbEcsSUFBSXlDLGdCQUFnQjdDLFdBQVc4QyxxQkFBcUIsR0FBR0MsR0FBRztZQUMxRCxJQUFJQyxZQUFZNUMsT0FBTzBDLHFCQUFxQixHQUFHQyxHQUFHO1lBQ2xELElBQUlFLGVBQWU3QyxPQUFPMEMscUJBQXFCLEdBQUdsQyxNQUFNO1lBQ3hELE1BQU1zQyxpQkFBaUJsRCxXQUFXOEMscUJBQXFCLEdBQUdsQyxNQUFNO1lBQ2hFLElBQUlxQyxlQUFlQyxnQkFBZ0I7Z0JBQy9CbEQsV0FBV1csU0FBUyxJQUFJcUMsWUFBWUg7WUFDeEM7UUFDSjtRQUNBLGFBQWE7UUFDYnpDLFNBQVNKLFdBQVdmLGFBQWE7SUFDckM7QUFDSjtBQUNBLFNBQVMrQixRQUFRWixNQUFNO0lBQ25CLE9BQU9BLGtCQUFrQitDLG9CQUFvQixDQUFDL0Qsa0JBQWtCZ0UsR0FBRyxDQUFDaEQsT0FBT3ZGLElBQUksS0FBS3VGLGtCQUFrQmlELHVCQUF1QmpELGtCQUFrQmtELGVBQWVsRCxPQUFPbUQsaUJBQWlCO0FBQzFMO0FBRUEsb0dBQW9HO0FBQ3BHOzs7Q0FHQyxHQUFHLFNBQVNDLE9BQU9DLEdBQUcsRUFBRWxCLEtBQUs7SUFDMUIsSUFBSSxPQUFPa0IsUUFBUSxZQUFZO1FBQzNCQSxJQUFJbEI7SUFDUixPQUFPLElBQUlrQixRQUFRLFFBQVFBLFFBQVFySCxXQUFXO1FBQzFDcUgsSUFBSS9ILE9BQU8sR0FBRzZHO0lBQ2xCO0FBQ0o7QUFDQTs7O0NBR0MsR0FBRyxTQUFTbUIsWUFBWSxHQUFHQyxJQUFJO0lBQzVCLE9BQU8sQ0FBQ2hGLE9BQU9nRixLQUFLQyxPQUFPLENBQUMsQ0FBQ0gsTUFBTUQsT0FBT0MsS0FBSzlFO0FBQ25EO0FBQ0E7OztDQUdDLEdBQUcsU0FBU2tGLGdCQUFnQixHQUFHRixJQUFJO0lBQ2hDLHVEQUF1RDtJQUN2RCxPQUFPeEksOENBQWlCLENBQUN1SSxlQUFlQyxPQUFPQTtBQUNuRDtBQUVBLElBQUlJLHVCQUF1QjtBQUMzQixTQUFTQyxpQkFBaUIsRUFBRXpILE1BQU0sRUFBRUssS0FBSyxFQUFFcUgsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLHdCQUF3QixFQUFFQyxZQUFZLEVBQUU7SUFDdEcsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdsSiwyQ0FBdUIsQ0FBQyxJQUFJLE1BQWtCLEdBQWNrRCxDQUFvQixHQUFHO0lBQ3JILE1BQU1vRyxZQUFZdEoseUNBQXFCLENBQUM7SUFDeEMsTUFBTXdKLG1CQUFtQnhKLDhDQUEwQixDQUFDO1FBQ2hELDhEQUE4RDtRQUM5RCxJQUFJMkkseUJBQXlCLFFBQVF4SCxVQUFVLENBQUM2SCxjQUFjO1lBQzFETCx1QkFBdUI7Z0JBQ25CYyxVQUFVckssU0FBUzZGLElBQUksQ0FBQzFGLEtBQUssQ0FBQ2tLLFFBQVE7Z0JBQ3RDOUIsS0FBS3ZJLFNBQVM2RixJQUFJLENBQUMxRixLQUFLLENBQUNvSSxHQUFHO2dCQUM1QitCLE1BQU10SyxTQUFTNkYsSUFBSSxDQUFDMUYsS0FBSyxDQUFDbUssSUFBSTtnQkFDOUJ4RCxRQUFROUcsU0FBUzZGLElBQUksQ0FBQzFGLEtBQUssQ0FBQzJHLE1BQU07Z0JBQ2xDeUQsT0FBTztZQUNYO1lBQ0EsMkNBQTJDO1lBQzNDLE1BQU0sRUFBRWxELE9BQU8sRUFBRU4sV0FBVyxFQUFFLEdBQUdqRDtZQUNqQzlELFNBQVM2RixJQUFJLENBQUMxRixLQUFLLENBQUNxSyxXQUFXLENBQUMsWUFBWSxTQUFTO1lBQ3JEQyxPQUFPQyxNQUFNLENBQUMxSyxTQUFTNkYsSUFBSSxDQUFDMUYsS0FBSyxFQUFFO2dCQUMvQm9JLEtBQUssQ0FBQyxFQUFFLENBQUMyQixVQUFVaEosT0FBTyxDQUFDLEVBQUUsQ0FBQztnQkFDOUJvSixNQUFNLENBQUMsRUFBRSxDQUFDakQsUUFBUSxFQUFFLENBQUM7Z0JBQ3JCa0QsT0FBTztnQkFDUHpELFFBQVE7WUFDWjtZQUNBaEQsT0FBTzZHLFVBQVUsQ0FBQyxJQUFJN0csT0FBTzhDLHFCQUFxQixDQUFDO29CQUMzQyx5RUFBeUU7b0JBQ3pFLE1BQU1nRSxrQkFBa0I3RCxjQUFjakQsT0FBT2lELFdBQVc7b0JBQ3hELElBQUk2RCxtQkFBbUJWLFVBQVVoSixPQUFPLElBQUk2RixhQUFhO3dCQUNyRCxxRUFBcUU7d0JBQ3JFL0csU0FBUzZGLElBQUksQ0FBQzFGLEtBQUssQ0FBQ29JLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBRTJCLENBQUFBLFVBQVVoSixPQUFPLEdBQUcwSixlQUFjLEVBQUcsRUFBRSxDQUFDO29CQUMzRTtnQkFDSixJQUFJO1FBQ1o7SUFDSixHQUFHO1FBQ0M3STtLQUNIO0lBQ0QsTUFBTThJLHlCQUF5QmpLLDhDQUEwQixDQUFDO1FBQ3RELElBQUkySSx5QkFBeUIsUUFBUSxDQUFDSyxjQUFjO1lBQ2hELHdDQUF3QztZQUN4QyxNQUFNMUQsSUFBSSxDQUFDNEUsU0FBUzlLLFNBQVM2RixJQUFJLENBQUMxRixLQUFLLENBQUNvSSxHQUFHLEVBQUU7WUFDN0MsTUFBTXdDLElBQUksQ0FBQ0QsU0FBUzlLLFNBQVM2RixJQUFJLENBQUMxRixLQUFLLENBQUNtSyxJQUFJLEVBQUU7WUFDOUMsaUJBQWlCO1lBQ2pCRyxPQUFPQyxNQUFNLENBQUMxSyxTQUFTNkYsSUFBSSxDQUFDMUYsS0FBSyxFQUFFb0o7WUFDbkN6RixPQUFPOEMscUJBQXFCLENBQUM7Z0JBQ3pCLElBQUkrQyw0QkFBNEJFLGNBQWMvRixPQUFPa0csUUFBUSxDQUFDQyxJQUFJLEVBQUU7b0JBQ2hFSCxhQUFhaEcsT0FBT2tHLFFBQVEsQ0FBQ0MsSUFBSTtvQkFDakM7Z0JBQ0o7Z0JBQ0FuRyxPQUFPc0QsUUFBUSxDQUFDMkQsR0FBRzdFO1lBQ3ZCO1lBQ0FxRCx1QkFBdUI7UUFDM0I7SUFDSixHQUFHO1FBQ0NNO0tBQ0g7SUFDRGpKLDRDQUF3QixDQUFDO1FBQ3JCLFNBQVNvSztZQUNMZCxVQUFVaEosT0FBTyxHQUFHNEMsT0FBT3lELE9BQU87UUFDdEM7UUFDQXlEO1FBQ0FsSCxPQUFPbUQsZ0JBQWdCLENBQUMsVUFBVStEO1FBQ2xDLE9BQU87WUFDSGxILE9BQU9xRSxtQkFBbUIsQ0FBQyxVQUFVNkM7UUFDekM7SUFDSixHQUFHLEVBQUU7SUFDTHBLLDRDQUF3QixDQUFDO1FBQ3JCLElBQUk2SSxVQUFVLENBQUNDLGVBQWU7UUFDOUIsaUlBQWlJO1FBQ2pJLElBQUkzSCxRQUFRO1lBQ1Isa0NBQWtDO1lBQ2xDLE1BQU1rSixlQUFlbkgsT0FBT29ILFVBQVUsQ0FBQyw4QkFBOEJDLE9BQU87WUFDNUUsQ0FBQ0YsZ0JBQWdCYjtZQUNqQixJQUFJLENBQUNoSSxPQUFPO2dCQUNSMEIsT0FBTzZHLFVBQVUsQ0FBQztvQkFDZEU7Z0JBQ0osR0FBRztZQUNQO1FBQ0osT0FBTztZQUNIQTtRQUNKO0lBQ0osR0FBRztRQUNDOUk7UUFDQTJIO1FBQ0FHO1FBQ0F6SDtRQUNBcUg7UUFDQVc7UUFDQVM7S0FDSDtJQUNELE9BQU87UUFDSEE7SUFDSjtBQUNKO0FBRUEsTUFBTU8sUUFBUSxJQUFJQztBQUNsQixTQUFTQyxJQUFJQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsY0FBYyxLQUFLO0lBQ3hDLElBQUksQ0FBQ0YsTUFBTSxDQUFFQSxDQUFBQSxjQUFjekMsV0FBVSxHQUFJO0lBQ3pDLElBQUk0QyxpQkFBaUIsQ0FBQztJQUN0QmpCLE9BQU9rQixPQUFPLENBQUNILFFBQVFwQyxPQUFPLENBQUMsQ0FBQyxDQUFDd0MsS0FBSzdELE1BQU07UUFDeEMsSUFBSTZELElBQUlDLFVBQVUsQ0FBQyxPQUFPO1lBQ3RCTixHQUFHcEwsS0FBSyxDQUFDcUssV0FBVyxDQUFDb0IsS0FBSzdEO1lBQzFCO1FBQ0o7UUFDQTJELGNBQWMsQ0FBQ0UsSUFBSSxHQUFHTCxHQUFHcEwsS0FBSyxDQUFDeUwsSUFBSTtRQUNuQ0wsR0FBR3BMLEtBQUssQ0FBQ3lMLElBQUksR0FBRzdEO0lBQ3BCO0lBQ0EsSUFBSTBELGFBQWE7SUFDakJMLE1BQU1FLEdBQUcsQ0FBQ0MsSUFBSUc7QUFDbEI7QUFDQSxTQUFTSSxNQUFNUCxFQUFFLEVBQUVRLElBQUk7SUFDbkIsSUFBSSxDQUFDUixNQUFNLENBQUVBLENBQUFBLGNBQWN6QyxXQUFVLEdBQUk7SUFDekMsSUFBSTRDLGlCQUFpQk4sTUFBTVksR0FBRyxDQUFDVDtJQUMvQixJQUFJLENBQUNHLGdCQUFnQjtRQUNqQjtJQUNKO0lBQ0EsSUFBSUssTUFBTTtRQUNOUixHQUFHcEwsS0FBSyxDQUFDNEwsS0FBSyxHQUFHTCxjQUFjLENBQUNLLEtBQUs7SUFDekMsT0FBTztRQUNIdEIsT0FBT2tCLE9BQU8sQ0FBQ0QsZ0JBQWdCdEMsT0FBTyxDQUFDLENBQUMsQ0FBQ3dDLEtBQUs3RCxNQUFNO1lBQ2hEd0QsR0FBR3BMLEtBQUssQ0FBQ3lMLElBQUksR0FBRzdEO1FBQ3BCO0lBQ0o7QUFDSjtBQUNBLE1BQU1rRSxhQUFhLENBQUNySjtJQUNoQixPQUFPQTtRQUNILEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBTztRQUNYO1lBQ0ksT0FBT0E7SUFDZjtBQUNKO0FBQ0EsU0FBU3NKLGFBQWFwRSxPQUFPLEVBQUVsRixTQUFTO0lBQ3BDLElBQUksQ0FBQ2tGLFNBQVM7UUFDVixPQUFPO0lBQ1g7SUFDQSxNQUFNM0gsUUFBUTJELE9BQU9NLGdCQUFnQixDQUFDMEQ7SUFDdEMsTUFBTXBCLFlBQ052RyxNQUFNdUcsU0FBUyxJQUFJdkcsTUFBTWdNLGVBQWUsSUFBSWhNLE1BQU1pTSxZQUFZO0lBQzlELElBQUlDLE1BQU0zRixVQUFVNEYsS0FBSyxDQUFDO0lBQzFCLElBQUlELEtBQUs7UUFDTCwrRUFBK0U7UUFDL0UsT0FBT0UsV0FBV0YsR0FBRyxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxDQUFDLEtBQUssQ0FBQ1AsV0FBV3JKLGFBQWEsS0FBSyxHQUFHO0lBQ3pFO0lBQ0EsNkVBQTZFO0lBQzdFeUosTUFBTTNGLFVBQVU0RixLQUFLLENBQUM7SUFDdEIsT0FBT0QsTUFBTUUsV0FBV0YsR0FBRyxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxDQUFDLEtBQUssQ0FBQ1AsV0FBV3JKLGFBQWEsSUFBSSxFQUFFLElBQUk7QUFDakY7QUFDQSxTQUFTNkosWUFBWUMsQ0FBQztJQUNsQixPQUFPLElBQUtDLENBQUFBLEtBQUtDLEdBQUcsQ0FBQ0YsSUFBSSxLQUFLO0FBQ2xDO0FBRUEsTUFBTUcsY0FBYztJQUNoQkMsVUFBVTtJQUNWQyxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtBQUNMO0FBQ0EsTUFBTUMscUJBQXFCO0FBRTNCLDJJQUEySTtBQUMzSSxTQUFTQyxlQUFlNUosUUFBUTtJQUM1QixNQUFNNkosY0FBY3RNLHlDQUFxQixDQUFDeUM7SUFDMUN6Qyw0Q0FBd0IsQ0FBQztRQUNyQnNNLFlBQVloTSxPQUFPLEdBQUdtQztJQUMxQjtJQUNBLGlEQUFpRDtJQUNqRCxPQUFPekMsMENBQXNCLENBQUMsSUFBSSxDQUFDLEdBQUd3QyxPQUFPOEosWUFBWWhNLE9BQU8sSUFBSSxPQUFPLEtBQUssSUFBSWdNLFlBQVloTSxPQUFPLENBQUNrTSxJQUFJLENBQUNGLGdCQUFnQjlKLE9BQU8sRUFBRTtBQUMxSTtBQUNBLFNBQVNpSyxxQkFBcUIsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUU7SUFDbkQsTUFBTUMsb0JBQW9CNU0sMkNBQXVCLENBQUMwTTtJQUNsRCxNQUFNLENBQUN2RixNQUFNLEdBQUd5RjtJQUNoQixNQUFNQyxlQUFlN00seUNBQXFCLENBQUNtSDtJQUMzQyxNQUFNMkYsZUFBZVQsZUFBZU07SUFDcEMzTSw0Q0FBd0IsQ0FBQztRQUNyQixJQUFJNk0sYUFBYXZNLE9BQU8sS0FBSzZHLE9BQU87WUFDaEMyRixhQUFhM0Y7WUFDYjBGLGFBQWF2TSxPQUFPLEdBQUc2RztRQUMzQjtJQUNKLEdBQUc7UUFDQ0E7UUFDQTBGO1FBQ0FDO0tBQ0g7SUFDRCxPQUFPRjtBQUNYO0FBQ0EsU0FBU0cscUJBQXFCLEVBQUU1QixJQUFJLEVBQUV1QixXQUFXLEVBQUVDLFdBQVcsS0FBSyxDQUFDLEVBQUU7SUFDbEUsTUFBTSxDQUFDSyxrQkFBa0JDLG9CQUFvQixHQUFHUixxQkFBcUI7UUFDakVDO1FBQ0FDO0lBQ0o7SUFDQSxNQUFNTyxlQUFlL0IsU0FBU25LO0lBQzlCLE1BQU1tRyxRQUFRK0YsZUFBZS9CLE9BQU82QjtJQUNwQyxNQUFNRixlQUFlVCxlQUFlTTtJQUNwQyxNQUFNUSxXQUFXbk4sOENBQTBCLENBQUMsQ0FBQ29OO1FBQ3pDLElBQUlGLGNBQWM7WUFDZCxNQUFNRyxTQUFTRDtZQUNmLE1BQU1qRyxRQUFRLE9BQU9pRyxjQUFjLGFBQWFDLE9BQU9sQyxRQUFRaUM7WUFDL0QsSUFBSWpHLFVBQVVnRSxNQUFNMkIsYUFBYTNGO1FBQ3JDLE9BQU87WUFDSDhGLG9CQUFvQkc7UUFDeEI7SUFDSixHQUFHO1FBQ0NGO1FBQ0EvQjtRQUNBOEI7UUFDQUg7S0FDSDtJQUNELE9BQU87UUFDSDNGO1FBQ0FnRztLQUNIO0FBQ0w7QUFFQSxTQUFTRyxjQUFjLEVBQUVDLG1CQUFtQixFQUFFQyxzQkFBc0IsRUFBRWpNLFVBQVUsRUFBRWxCLFNBQVMsRUFBRUUsVUFBVSxFQUFFa04sYUFBYSxFQUFFQyxpQkFBaUIsRUFBRTFMLFlBQVksUUFBUSxFQUFFO0lBQzdKLE1BQU0sQ0FBQ04saUJBQWlCRSxtQkFBbUIsR0FBR21MLHFCQUFxQjtRQUMvRDVCLE1BQU1vQztRQUNOYixhQUFhbkwsY0FBYyxPQUFPLEtBQUssSUFBSUEsVUFBVSxDQUFDLEVBQUU7UUFDeERvTCxVQUFVYTtJQUNkO0lBQ0EsTUFBTUcsa0JBQWtCM04sMENBQXNCLENBQUMsSUFBSTBCLG9CQUFxQkgsQ0FBQUEsY0FBYyxPQUFPLEtBQUssSUFBSUEsVUFBVSxDQUFDQSxXQUFXcU0sTUFBTSxHQUFHLEVBQUUsS0FBSyxNQUFNO1FBQzlJck07UUFDQUc7S0FDSDtJQUNELE1BQU1ELGFBQWFGLGNBQWNBLFdBQVdxTSxNQUFNLEdBQUcsS0FBTUgsQ0FBQUEsaUJBQWlCQSxrQkFBa0IsTUFBTSxDQUFDSSxPQUFPQyxLQUFLLENBQUNMLGtCQUFrQmxNLFVBQVUsQ0FBQ2tNLGNBQWMsS0FBSy9MLG1CQUFtQixDQUFDSDtJQUN0TCxNQUFNd00sdUJBQXVCL04sMENBQXNCLENBQUMsSUFBSXVCLGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVd5TSxTQUFTLENBQUMsQ0FBQ0MsWUFBWUEsY0FBY3ZNLGtCQUFrQjtRQUNwSkg7UUFDQUc7S0FDSDtJQUNELE1BQU1KLG1CQUFtQnRCLDBDQUFzQixDQUFDO1FBQzVDLElBQUlrTztRQUNKLE9BQU8sQ0FBQ0Esa0JBQWtCM00sY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBVzRNLEdBQUcsQ0FBQyxDQUFDRjtZQUNwRSxNQUFNRyxZQUFZLGdCQUFrQjtZQUNwQyxNQUFNQyxPQUFPLE9BQU9KLGNBQWM7WUFDbEMsSUFBSUssb0JBQW9CO1lBQ3hCLElBQUlELE1BQU07Z0JBQ05DLG9CQUFvQnBFLFNBQVMrRCxXQUFXO1lBQzVDO1lBQ0EsSUFBSTVDLFdBQVdySixZQUFZO2dCQUN2QixNQUFNa0UsU0FBU21JLE9BQU9DLG9CQUFvQkYsWUFBWUgsWUFBWS9LLE9BQU9pRCxXQUFXLEdBQUc7Z0JBQ3ZGLElBQUlpSSxXQUFXO29CQUNYLE9BQU9wTSxjQUFjLFdBQVdrQixPQUFPaUQsV0FBVyxHQUFHRCxTQUFTLENBQUNoRCxPQUFPaUQsV0FBVyxHQUFHRDtnQkFDeEY7Z0JBQ0EsT0FBT0E7WUFDWDtZQUNBLE1BQU1xSSxRQUFRRixPQUFPQyxvQkFBb0JGLFlBQVlILFlBQVkvSyxPQUFPd0IsVUFBVSxHQUFHO1lBQ3JGLElBQUkwSixXQUFXO2dCQUNYLE9BQU9wTSxjQUFjLFVBQVVrQixPQUFPd0IsVUFBVSxHQUFHNkosUUFBUSxDQUFDckwsT0FBT3dCLFVBQVUsR0FBRzZKO1lBQ3BGO1lBQ0EsT0FBT0E7UUFDWCxFQUFDLEtBQU0sT0FBT0wsa0JBQWtCLEVBQUU7SUFDdEMsR0FBRztRQUNDM007S0FDSDtJQUNELE1BQU1pTix3QkFBd0J4TywwQ0FBc0IsQ0FBQyxJQUFJK04seUJBQXlCLE9BQU96TSxvQkFBb0IsT0FBTyxLQUFLLElBQUlBLGdCQUFnQixDQUFDeU0scUJBQXFCLEdBQUcsTUFBTTtRQUN4S3pNO1FBQ0F5TTtLQUNIO0lBQ0QsTUFBTVUsY0FBY3pPLDhDQUEwQixDQUFDLENBQUMwTztRQUM1QyxJQUFJQztRQUNKLE1BQU1DLG9CQUFvQixDQUFDRCw4QkFBOEJyTixvQkFBb0IsT0FBTyxLQUFLLElBQUlBLGlCQUFpQjBNLFNBQVMsQ0FBQyxDQUFDYSxlQUFlQSxpQkFBaUJILFVBQVMsS0FBTSxPQUFPQyw4QkFBOEI7UUFDN01qQixrQkFBa0JrQjtRQUNsQmxFLElBQUlySyxVQUFVQyxPQUFPLEVBQUU7WUFDbkJ3TyxZQUFZLENBQUMsVUFBVSxFQUFFN0MsWUFBWUMsUUFBUSxDQUFDLGVBQWUsRUFBRUQsWUFBWUUsSUFBSSxDQUFDNEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVGakosV0FBV3VGLFdBQVdySixhQUFhLENBQUMsZUFBZSxFQUFFME0sVUFBVSxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRUEsVUFBVSxTQUFTLENBQUM7UUFDaEg7UUFDQSxJQUFJcE4sb0JBQW9Cc04sc0JBQXNCdE4saUJBQWlCc00sTUFBTSxHQUFHLEtBQUtnQixzQkFBc0JuQixlQUFlO1lBQzlHL0MsSUFBSW5LLFdBQVdELE9BQU8sRUFBRTtnQkFDcEJ3TyxZQUFZLENBQUMsUUFBUSxFQUFFN0MsWUFBWUMsUUFBUSxDQUFDLGVBQWUsRUFBRUQsWUFBWUUsSUFBSSxDQUFDNEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMxRkMsU0FBUztZQUNiO1FBQ0osT0FBTztZQUNIdEUsSUFBSW5LLFdBQVdELE9BQU8sRUFBRTtnQkFDcEJ3TyxZQUFZLENBQUMsUUFBUSxFQUFFN0MsWUFBWUMsUUFBUSxDQUFDLGVBQWUsRUFBRUQsWUFBWUUsSUFBSSxDQUFDNEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMxRkMsU0FBUztZQUNiO1FBQ0o7UUFDQXBOLG1CQUFtQmdOLHNCQUFzQixPQUFPck4sY0FBYyxPQUFPLEtBQUssSUFBSUEsVUFBVSxDQUFDcU4sa0JBQWtCLEdBQUc7SUFDbEgsR0FBRztRQUNDdk8sVUFBVUMsT0FBTztRQUNqQmlCO1FBQ0FEO1FBQ0FtTTtRQUNBbE47UUFDQXFCO0tBQ0g7SUFDRDVCLDRDQUF3QixDQUFDO1FBQ3JCLElBQUkwQixtQkFBbUI2TCxxQkFBcUI7WUFDeEMsSUFBSTBCO1lBQ0osTUFBTUMsV0FBVyxDQUFDRCx3QkFBd0IxTixjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXeU0sU0FBUyxDQUFDLENBQUNDLFlBQVlBLGNBQWNWLHVCQUF1QlUsY0FBY3ZNLGdCQUFlLEtBQU0sT0FBT3VOLHdCQUF3QixDQUFDO1lBQ2xOLElBQUkzTixvQkFBb0I0TixhQUFhLENBQUMsS0FBSyxPQUFPNU4sZ0JBQWdCLENBQUM0TixTQUFTLEtBQUssVUFBVTtnQkFDdkZULFlBQVluTixnQkFBZ0IsQ0FBQzROLFNBQVM7WUFDMUM7UUFDSjtJQUNKLEdBQUc7UUFDQ3hOO1FBQ0E2TDtRQUNBaE07UUFDQUQ7UUFDQW1OO0tBQ0g7SUFDRCxTQUFTL04sVUFBVSxFQUFFeU8sZUFBZSxFQUFFck4sV0FBVyxFQUFFc04sUUFBUSxFQUFFbk8sV0FBVyxFQUFFO1FBQ3RFLElBQUl3TSxrQkFBa0J6TSxXQUFXO1FBQ2pDLE1BQU1xTyxrQkFBa0JyTixjQUFjLFlBQVlBLGNBQWMsVUFBVSxDQUFDd00seUJBQXlCLE9BQU9BLHdCQUF3QixLQUFLVyxrQkFBa0IsQ0FBQ1gseUJBQXlCLE9BQU9BLHdCQUF3QixLQUFLVztRQUN4TixNQUFNRyxxQkFBcUJ2Qix5QkFBeUJOLGdCQUFnQjtRQUNwRSxNQUFNOEIsVUFBVXhCLHlCQUF5QjtRQUN6QyxNQUFNeUIsZUFBZUwsa0JBQWtCO1FBQ3ZDLElBQUlHLG9CQUFvQjtZQUNwQjVFLElBQUluSyxXQUFXRCxPQUFPLEVBQUU7Z0JBQ3BCd08sWUFBWSxDQUFDLFFBQVEsRUFBRTdDLFlBQVlDLFFBQVEsQ0FBQyxlQUFlLEVBQUVELFlBQVlFLElBQUksQ0FBQzRDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5RjtRQUNKO1FBQ0EsSUFBSUssV0FBVyxLQUFLLENBQUNJLGNBQWM7WUFDL0IsSUFBSXZPLGFBQWFhO2lCQUNaMk0sWUFBWW5OLGdCQUFnQixDQUFDLEVBQUUsR0FBRyx3QkFBd0I7WUFDL0Q7UUFDSjtRQUNBLElBQUk4TixXQUFXLEtBQUtJLGdCQUFnQmxPLG9CQUFvQkMsWUFBWTtZQUNoRWtOLFlBQVluTixnQkFBZ0IsQ0FBQ0MsV0FBV3FNLE1BQU0sR0FBRyxFQUFFO1lBQ25EO1FBQ0o7UUFDQSxzREFBc0Q7UUFDdEQsTUFBTTZCLG1CQUFtQm5PLG9CQUFvQixPQUFPLEtBQUssSUFBSUEsaUJBQWlCb08sTUFBTSxDQUFDLENBQUNDLE1BQU1DO1lBQ3hGLElBQUksT0FBT0QsU0FBUyxZQUFZLE9BQU9DLFNBQVMsVUFBVSxPQUFPRDtZQUNqRSxPQUFPNUQsS0FBSzhELEdBQUcsQ0FBQ0QsT0FBT1AsbUJBQW1CdEQsS0FBSzhELEdBQUcsQ0FBQ0YsT0FBT04sbUJBQW1CTyxPQUFPRDtRQUN4RjtRQUNBLE1BQU1HLE1BQU16RSxXQUFXckosYUFBYWtCLE9BQU9pRCxXQUFXLEdBQUdqRCxPQUFPd0IsVUFBVTtRQUMxRSxJQUFJMEssV0FBV2hELHNCQUFzQkwsS0FBSzhELEdBQUcsQ0FBQ1YsbUJBQW1CVyxNQUFNLEtBQUs7WUFDeEUsTUFBTUMsZ0JBQWdCUCxlQUFlLElBQUksQ0FBQyxHQUFHLG9CQUFvQjtZQUNqRSwyRUFBMkU7WUFDM0UsSUFBSU8sZ0JBQWdCLEtBQUtwQyxpQkFBaUI7Z0JBQ3RDYyxZQUFZbk4sZ0JBQWdCLENBQUNDLFdBQVdxTSxNQUFNLEdBQUcsRUFBRTtnQkFDbkQ7WUFDSjtZQUNBLElBQUkyQixXQUFXUSxnQkFBZ0IsS0FBSzlPLGFBQWE7Z0JBQzdDYTtZQUNKO1lBQ0EsSUFBSWlNLHlCQUF5QixNQUFNO1lBQ25DVSxZQUFZbk4sZ0JBQWdCLENBQUN5TSx1QkFBdUJnQyxjQUFjO1lBQ2xFO1FBQ0o7UUFDQXRCLFlBQVlnQjtJQUNoQjtJQUNBLFNBQVM5TyxPQUFPLEVBQUV3TyxlQUFlLEVBQUU7UUFDL0IsSUFBSVgsMEJBQTBCLE1BQU07UUFDcEMsTUFBTXdCLFdBQVdoTyxjQUFjLFlBQVlBLGNBQWMsVUFBVXdNLHdCQUF3Qlcsa0JBQWtCWCx3QkFBd0JXO1FBQ3JJLDhEQUE4RDtRQUM5RCxJQUFJLENBQUNuTixjQUFjLFlBQVlBLGNBQWMsT0FBTSxLQUFNZ08sV0FBVzFPLGdCQUFnQixDQUFDQSxpQkFBaUJzTSxNQUFNLEdBQUcsRUFBRSxFQUFFO1lBQy9HO1FBQ0o7UUFDQSxJQUFJLENBQUM1TCxjQUFjLFNBQVNBLGNBQWMsTUFBSyxLQUFNZ08sV0FBVzFPLGdCQUFnQixDQUFDQSxpQkFBaUJzTSxNQUFNLEdBQUcsRUFBRSxFQUFFO1lBQzNHO1FBQ0o7UUFDQWxELElBQUlySyxVQUFVQyxPQUFPLEVBQUU7WUFDbkJ3RixXQUFXdUYsV0FBV3JKLGFBQWEsQ0FBQyxlQUFlLEVBQUVnTyxTQUFTLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFQSxTQUFTLFNBQVMsQ0FBQztRQUM5RztJQUNKO0lBQ0EsU0FBU0MscUJBQXFCQyxrQkFBa0IsRUFBRUMsY0FBYztRQUM1RCxJQUFJLENBQUM1TyxjQUFjLE9BQU93TSx5QkFBeUIsWUFBWSxDQUFDek0sb0JBQW9CbU0sa0JBQWtCek0sV0FBVyxPQUFPO1FBQ3hILHNGQUFzRjtRQUN0RixNQUFNc08scUJBQXFCdkIseUJBQXlCTixnQkFBZ0I7UUFDcEUsTUFBTTJDLDZCQUE2QnJDLHdCQUF3Qk47UUFDM0QsSUFBSTJDLDhCQUE4QkQsZ0JBQWdCO1lBQzlDLE9BQU87UUFDWDtRQUNBLDBGQUEwRjtRQUMxRixJQUFJYixzQkFBc0IsQ0FBQ2EsZ0JBQWdCLE9BQU87UUFDbEQsSUFBSSxDQUFDMU8sY0FBYyxDQUFDNk4sb0JBQW9CLE9BQU87UUFDL0MsMENBQTBDO1FBQzFDLE1BQU1lLHVCQUF1QmYscUJBQXFCdkIsdUJBQXVCLElBQUlBLHVCQUF1QjtRQUNwRyx5SEFBeUg7UUFDekgsTUFBTXVDLG9CQUFvQmhCLHFCQUFxQmhPLGdCQUFnQixDQUFDK08scUJBQXFCLEdBQUcvTyxnQkFBZ0IsQ0FBQytPLHVCQUF1QixFQUFFLEdBQUcvTyxnQkFBZ0IsQ0FBQytPLHVCQUF1QixFQUFFLEdBQUcvTyxnQkFBZ0IsQ0FBQytPLHFCQUFxQjtRQUN4TixNQUFNRSxvQkFBb0JMLHFCQUFxQm5FLEtBQUs4RCxHQUFHLENBQUNTO1FBQ3hELElBQUloQixvQkFBb0I7WUFDcEIsT0FBTyxJQUFJaUI7UUFDZixPQUFPO1lBQ0gsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsT0FBTztRQUNINUM7UUFDQWpNO1FBQ0FEO1FBQ0F3TztRQUNBck87UUFDQW1NO1FBQ0FyTjtRQUNBQztRQUNBVztJQUNKO0FBQ0o7QUFFQSxNQUFNa1Asa0JBQWtCO0FBQ3hCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsc0JBQXNCO0FBQzVCLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyxhQUFhO0FBQ25CLFNBQVNDLEtBQUssRUFBRUMsTUFBTWhRLFFBQVEsRUFBRVksWUFBWSxFQUFFcVAsUUFBUSxFQUFFQyxxQkFBcUIsRUFBRXRRLFFBQVF1USxVQUFVLEVBQUV4USxXQUFXeVEsYUFBYSxFQUFFNVAsVUFBVSxFQUFFc0gsU0FBUyxLQUFLLEVBQUV1SSw0QkFBNEIsSUFBSSxFQUFFQyxpQkFBaUJiLGVBQWUsRUFBRWMsb0JBQW9CYixtQkFBbUIsRUFBRXhQLGNBQWMsSUFBSSxFQUFFQyxhQUFhLEtBQUssRUFBRXVNLGdCQUFnQmxNLGNBQWNBLFdBQVdxTSxNQUFNLEdBQUcsQ0FBQyxFQUFFbE0saUJBQWlCNkwsbUJBQW1CLEVBQUUzTCxvQkFBb0I0TCxzQkFBc0IsRUFBRStELEtBQUssRUFBRS9QLFFBQVEsSUFBSSxFQUFFZ1EsT0FBTyxFQUFFeEksWUFBWSxFQUFFaEgsWUFBWSxRQUFRLEVBQUUrRywyQkFBMkIsSUFBSSxFQUFFMEksdUJBQXVCLEtBQUssRUFBRTtJQUNsakIsSUFBSUM7SUFDSixNQUFNLENBQUN2USxTQUFTLEtBQUssRUFBRXdRLFVBQVUsR0FBRzNSLDJDQUF1QixDQUFDO0lBQzVELE1BQU0sQ0FBQzhJLGVBQWU4SSxpQkFBaUIsR0FBRzVSLDJDQUF1QixDQUFDO0lBQ2xFLGlDQUFpQztJQUNqQyxNQUFNLENBQUM2QixTQUFTRSxXQUFXLEdBQUcvQiwyQ0FBdUIsQ0FBQztJQUN0RCxNQUFNLENBQUM2UixTQUFTQyxXQUFXLEdBQUc5UiwyQ0FBdUIsQ0FBQztJQUN0RCxNQUFNLENBQUNvQixZQUFZMlEsY0FBYyxHQUFHL1IsMkNBQXVCLENBQUM7SUFDNUQsTUFBTSxDQUFDZ1MsY0FBY0MsZ0JBQWdCLEdBQUdqUywyQ0FBdUIsQ0FBQztJQUNoRSxNQUFNTyxhQUFhUCx5Q0FBcUIsQ0FBQztJQUN6QyxNQUFNa1MsV0FBV2xTLHlDQUFxQixDQUFDO0lBQ3ZDLE1BQU1tUyxnQkFBZ0JuUyx5Q0FBcUIsQ0FBQztJQUM1QyxNQUFNb1MsY0FBY3BTLHlDQUFxQixDQUFDO0lBQzFDLE1BQU1xUyx3QkFBd0JyUyx5Q0FBcUIsQ0FBQztJQUNwRCxNQUFNc1Msa0JBQWtCdFMseUNBQXFCLENBQUM7SUFDOUMsTUFBTXVTLHdCQUF3QnZTLHlDQUFxQixDQUFDO0lBQ3BELE1BQU13UyxlQUFleFMseUNBQXFCLENBQUM7SUFDM0MsTUFBTXFCLGlCQUFpQnJCLHlDQUFxQixDQUFDO0lBQzdDLE1BQU15UywwQkFBMEJ6Uyx5Q0FBcUIsQ0FBQztJQUN0RCxNQUFNSyxZQUFZTCx5Q0FBcUIsQ0FBQztJQUN4QyxNQUFNMFMsa0JBQWtCMVMseUNBQXFCLENBQUMsQ0FBQyxDQUFDMFIscUJBQXFCclIsVUFBVUMsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJb1IsbUJBQW1CaEsscUJBQXFCLEdBQUd4QixNQUFNLEtBQUs7SUFDakssTUFBTXlNLHNCQUFzQjNTLHlDQUFxQixDQUFDO0lBQ2xELE1BQU0wTixvQkFBb0IxTiw4Q0FBMEIsQ0FBQyxDQUFDK047UUFDbEQsOEdBQThHO1FBQzlHLElBQUl4TSxjQUFjd00seUJBQXlCek0saUJBQWlCc00sTUFBTSxHQUFHLEdBQUdzRSxTQUFTNVIsT0FBTyxHQUFHLElBQUlzUztJQUNuRyxHQUFHLEVBQUU7SUFDTCxNQUFNLEVBQUVsUixlQUFlLEVBQUVxTSxvQkFBb0IsRUFBRW5NLGtCQUFrQixFQUFFbEIsV0FBV21TLG1CQUFtQixFQUFFdlIsZ0JBQWdCLEVBQUVYLFFBQVFtUyxnQkFBZ0IsRUFBRXJSLFVBQVUsRUFBRXdPLHNCQUFzQjhDLDhCQUE4QixFQUFFLEdBQUd6RixjQUFjO1FBQzlOL0w7UUFDQWdNO1FBQ0FDO1FBQ0FuTjtRQUNBb047UUFDQWxOO1FBQ0FtTjtRQUNBMUw7SUFDSjtJQUNBb0MsaUJBQWlCO1FBQ2JFLFlBQVksQ0FBQ25ELFVBQVVDLGNBQWMsQ0FBQ0ksU0FBU3dRLGdCQUFnQixDQUFDbEosaUJBQWlCMkk7SUFDckY7SUFDQSxNQUFNLEVBQUV4SCxzQkFBc0IsRUFBRSxHQUFHckIsaUJBQWlCO1FBQ2hEekg7UUFDQUs7UUFDQXFIO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0o7SUFDQSxTQUFTZ0s7UUFDTCxPQUFPLENBQUM5UCxPQUFPd0IsVUFBVSxHQUFHa00saUJBQWdCLElBQUsxTixPQUFPd0IsVUFBVTtJQUN0RTtJQUNBLFNBQVNqRSxRQUFRNEcsS0FBSztRQUNsQixJQUFJcUs7UUFDSixJQUFJLENBQUN6USxlQUFlLENBQUNNLFlBQVk7UUFDakMsSUFBSWxCLFVBQVVDLE9BQU8sSUFBSSxDQUFDRCxVQUFVQyxPQUFPLENBQUMyUyxRQUFRLENBQUM1TCxNQUFNckMsTUFBTSxHQUFHO1FBQ3BFME4sZ0JBQWdCcFMsT0FBTyxHQUFHLENBQUMsQ0FBQ29SLHFCQUFxQnJSLFVBQVVDLE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSW9SLG1CQUFtQmhLLHFCQUFxQixHQUFHeEIsTUFBTSxLQUFLO1FBQzdJNkwsY0FBYztRQUNkSSxjQUFjN1IsT0FBTyxHQUFHLElBQUlzUztRQUM1Qiw0R0FBNEc7UUFDNUcsSUFBSTVQLFNBQVM7WUFDVEUsT0FBT21ELGdCQUFnQixDQUFDLFlBQVksSUFBSWlNLGdCQUFnQmhTLE9BQU8sR0FBRyxPQUFPO2dCQUNyRWdHLE1BQU07WUFDVjtRQUNKO1FBQ0EsbUZBQW1GO1FBQ25GZSxNQUFNckMsTUFBTSxDQUFDa08saUJBQWlCLENBQUM3TCxNQUFNOEwsU0FBUztRQUM5Q1gsYUFBYWxTLE9BQU8sR0FBRytLLFdBQVdySixhQUFhcUYsTUFBTStMLE9BQU8sR0FBRy9MLE1BQU1nTSxPQUFPO0lBQ2hGO0lBQ0EsU0FBU0MsV0FBVzNJLEVBQUUsRUFBRTRJLHFCQUFxQjtRQUN6QyxJQUFJQztRQUNKLElBQUl0TSxVQUFVeUQ7UUFDZCxNQUFNOEksa0JBQWtCLENBQUNELHVCQUF1QnRRLE9BQU93USxZQUFZLEVBQUMsS0FBTSxPQUFPLEtBQUssSUFBSUYscUJBQXFCRyxRQUFRO1FBQ3ZILE1BQU1DLGNBQWN2VCxVQUFVQyxPQUFPLEdBQUdnTCxhQUFhakwsVUFBVUMsT0FBTyxFQUFFMEIsYUFBYTtRQUNyRixNQUFNNlIsT0FBTyxJQUFJakI7UUFDakIsSUFBSTFMLFFBQVE0TSxZQUFZLENBQUMsd0JBQXdCNU0sUUFBUTZNLE9BQU8sQ0FBQyx3QkFBd0I7WUFDckYsT0FBTztRQUNYO1FBQ0EsSUFBSS9SLGNBQWMsV0FBV0EsY0FBYyxRQUFRO1lBQy9DLE9BQU87UUFDWDtRQUNBLGlDQUFpQztRQUNqQyxJQUFJa1EsU0FBUzVSLE9BQU8sSUFBSXVULEtBQUtHLE9BQU8sS0FBSzlCLFNBQVM1UixPQUFPLENBQUMwVCxPQUFPLEtBQUssS0FBSztZQUN2RSxPQUFPO1FBQ1g7UUFDQSxJQUFJSixnQkFBZ0IsTUFBTTtZQUN0QixJQUFJNVIsY0FBYyxXQUFXNFIsY0FBYyxJQUFJQSxjQUFjLEdBQUc7Z0JBQzVELE9BQU87WUFDWDtRQUNKO1FBQ0EseUNBQXlDO1FBQ3pDLElBQUlILG1CQUFtQkEsZ0JBQWdCN0YsTUFBTSxHQUFHLEdBQUc7WUFDL0MsT0FBTztRQUNYO1FBQ0Esc0VBQXNFO1FBQ3RFLElBQUl5RSxzQkFBc0IvUixPQUFPLElBQUl1VCxLQUFLRyxPQUFPLEtBQUszQixzQkFBc0IvUixPQUFPLENBQUMwVCxPQUFPLEtBQUsxQyxxQkFBcUJzQyxnQkFBZ0IsR0FBRztZQUNwSXZCLHNCQUFzQi9SLE9BQU8sR0FBR3VUO1lBQ2hDLE9BQU87UUFDWDtRQUNBLElBQUlOLHVCQUF1QjtZQUN2QmxCLHNCQUFzQi9SLE9BQU8sR0FBR3VUO1lBQ2hDLG9EQUFvRDtZQUNwRCxPQUFPO1FBQ1g7UUFDQSw0REFBNEQ7UUFDNUQsTUFBTTNNLFFBQVE7WUFDVixxQ0FBcUM7WUFDckMsSUFBSUEsUUFBUXpCLFlBQVksR0FBR3lCLFFBQVF4QixZQUFZLEVBQUU7Z0JBQzdDLElBQUl3QixRQUFRM0IsU0FBUyxLQUFLLEdBQUc7b0JBQ3pCOE0sc0JBQXNCL1IsT0FBTyxHQUFHLElBQUlzUztvQkFDcEMsdUVBQXVFO29CQUN2RSxPQUFPO2dCQUNYO2dCQUNBLElBQUkxTCxRQUFRK00sWUFBWSxDQUFDLFlBQVksVUFBVTtvQkFDM0MsT0FBTztnQkFDWDtZQUNKO1lBQ0EsZ0NBQWdDO1lBQ2hDL00sVUFBVUEsUUFBUWdOLFVBQVU7UUFDaEM7UUFDQSwrREFBK0Q7UUFDL0QsT0FBTztJQUNYO0lBQ0EsU0FBU3ZULE9BQU8wRyxLQUFLO1FBQ2pCLElBQUksQ0FBQ2hILFVBQVVDLE9BQU8sRUFBRTtZQUNwQjtRQUNKO1FBQ0EseUhBQXlIO1FBQ3pILElBQUljLFlBQVk7WUFDWixNQUFNK1Msc0JBQXNCblMsY0FBYyxZQUFZQSxjQUFjLFVBQVUsSUFBSSxDQUFDO1lBQ25GLE1BQU1tTixrQkFBa0IsQ0FBQ3FELGFBQWFsUyxPQUFPLEdBQUkrSyxDQUFBQSxXQUFXckosYUFBYXFGLE1BQU0rTCxPQUFPLEdBQUcvTCxNQUFNZ00sT0FBTyxLQUFLYztZQUMzRyxNQUFNWix3QkFBd0JwRSxrQkFBa0I7WUFDaEQsaUVBQWlFO1lBQ2pFLE1BQU1pRixnQ0FBZ0M3UyxjQUFjLENBQUNOLGVBQWUsQ0FBQ3NTO1lBQ3JFLGdIQUFnSDtZQUNoSCxJQUFJYSxpQ0FBaUNyRyx5QkFBeUIsR0FBRztZQUNqRSw4RkFBOEY7WUFDOUYsTUFBTW1DLHFCQUFxQm5FLEtBQUs4RCxHQUFHLENBQUNWO1lBQ3BDLE1BQU1rRixVQUFValYsU0FBU2tWLGFBQWEsQ0FBQztZQUN2QyxtRUFBbUU7WUFDbkUsSUFBSS9ELG9CQUFvQkwscUJBQXFCd0MsZ0JBQWdCcFMsT0FBTztZQUNwRSxNQUFNaVUsNkJBQTZCeEIsK0JBQStCN0Msb0JBQW9CcUQ7WUFDdEYsSUFBSWdCLCtCQUErQixNQUFNO2dCQUNyQ2hFLG9CQUFvQmdFO1lBQ3hCO1lBQ0EsMERBQTBEO1lBQzFELElBQUlILGlDQUFpQzdELHFCQUFxQixHQUFHO2dCQUN6RDtZQUNKO1lBQ0EsSUFBSSxDQUFDK0IsZ0JBQWdCaFMsT0FBTyxJQUFJLENBQUNnVCxXQUFXak0sTUFBTXJDLE1BQU0sRUFBRXVPLHdCQUF3QjtZQUNsRmxULFVBQVVDLE9BQU8sQ0FBQ2tVLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDNUQ7WUFDaEMsNk5BQTZOO1lBQzdOeUIsZ0JBQWdCaFMsT0FBTyxHQUFHO1lBQzFCb0ssSUFBSXJLLFVBQVVDLE9BQU8sRUFBRTtnQkFDbkJ3TyxZQUFZO1lBQ2hCO1lBQ0FwRSxJQUFJbkssV0FBV0QsT0FBTyxFQUFFO2dCQUNwQndPLFlBQVk7WUFDaEI7WUFDQSxJQUFJdk4sWUFBWTtnQkFDWnVSLGlCQUFpQjtvQkFDYjNEO2dCQUNKO1lBQ0o7WUFDQSxnR0FBZ0c7WUFDaEcsSUFBSW9FLHlCQUF5QixDQUFDaFMsWUFBWTtnQkFDdEMsTUFBTW1ULDBCQUEwQjdJLFlBQVlzRDtnQkFDNUMsTUFBTXdGLGlCQUFpQjVJLEtBQUs2SSxHQUFHLENBQUNGLDBCQUEwQixDQUFDLEdBQUcsS0FBS1A7Z0JBQ25FekosSUFBSXJLLFVBQVVDLE9BQU8sRUFBRTtvQkFDbkJ3RixXQUFXdUYsV0FBV3JKLGFBQWEsQ0FBQyxlQUFlLEVBQUUyUyxlQUFlLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFQSxlQUFlLFNBQVMsQ0FBQztnQkFDMUg7Z0JBQ0E7WUFDSjtZQUNBLE1BQU1FLGVBQWUsSUFBSXRFO1lBQ3pCLElBQUk5TyxjQUFjZ00saUJBQWlCTSx5QkFBeUJOLGdCQUFnQixHQUFHO2dCQUMzRXlELGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVc3SixPQUFPa0o7Z0JBQ2hEN0YsSUFBSW5LLFdBQVdELE9BQU8sRUFBRTtvQkFDcEIwTyxTQUFTLENBQUMsRUFBRTZGLGFBQWEsQ0FBQztvQkFDMUIvRixZQUFZO2dCQUNoQixHQUFHO1lBQ1A7WUFDQSxJQUFJdUYsV0FBVzlULFdBQVdELE9BQU8sSUFBSTJRLHVCQUF1QjtnQkFDeEQscURBQXFEO2dCQUNyRCxNQUFNNkQsYUFBYS9JLEtBQUs2SSxHQUFHLENBQUM1QixhQUFhekMsb0JBQXFCLEtBQUl5QyxVQUFTLEdBQUk7Z0JBQy9FLE1BQU0rQixvQkFBb0IsSUFBSXhFLG9CQUFvQjtnQkFDbEQsTUFBTW9FLGlCQUFpQjVJLEtBQUtpSixHQUFHLENBQUMsR0FBRyxLQUFLekUsb0JBQW9CO2dCQUM1RDdGLElBQUkySixTQUFTO29CQUNUWSxjQUFjLENBQUMsRUFBRUYsa0JBQWtCLEVBQUUsQ0FBQztvQkFDdENqUCxXQUFXdUYsV0FBV3JKLGFBQWEsQ0FBQyxNQUFNLEVBQUU4UyxXQUFXLGlCQUFpQixFQUFFSCxlQUFlLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFRyxXQUFXLGNBQWMsRUFBRUgsZUFBZSxTQUFTLENBQUM7b0JBQ2hLN0YsWUFBWTtnQkFDaEIsR0FBRztZQUNQO1lBQ0EsSUFBSSxDQUFDdk4sWUFBWTtnQkFDYixNQUFNb1QsaUJBQWlCekUscUJBQXFCaUU7Z0JBQzVDekosSUFBSXJLLFVBQVVDLE9BQU8sRUFBRTtvQkFDbkJ3RixXQUFXdUYsV0FBV3JKLGFBQWEsQ0FBQyxlQUFlLEVBQUUyUyxlQUFlLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFQSxlQUFlLFNBQVMsQ0FBQztnQkFDMUg7WUFDSjtRQUNKO0lBQ0o7SUFDQTNVLDRDQUF3QixDQUFDO1FBQ3JCLE9BQU87WUFDSFEsZ0JBQWdCO1lBQ2hCeUo7UUFDSjtJQUNKLEdBQUcsRUFBRTtJQUNMakssNENBQXdCLENBQUM7UUFDckIsSUFBSWtWO1FBQ0osU0FBU0M7WUFDTCxJQUFJLENBQUM5VSxVQUFVQyxPQUFPLEVBQUU7WUFDeEIsTUFBTThVLGlCQUFpQmhXLFNBQVN5RyxhQUFhO1lBQzdDLElBQUlELFFBQVF3UCxtQkFBbUIvVCxlQUFlZixPQUFPLEVBQUU7Z0JBQ25ELElBQUk0VTtnQkFDSixNQUFNRyx1QkFBdUIsQ0FBQyxDQUFDSCx5QkFBeUJoUyxPQUFPRyxjQUFjLEtBQUssT0FBTyxLQUFLLElBQUk2Uix1QkFBdUJoUCxNQUFNLEtBQUs7Z0JBQ3BJLHFDQUFxQztnQkFDckMsSUFBSW9QLGtCQUFrQnBTLE9BQU9pRCxXQUFXLEdBQUdrUDtnQkFDM0MsTUFBTUUsZUFBZWxWLFVBQVVDLE9BQU8sQ0FBQ29ILHFCQUFxQixHQUFHeEIsTUFBTSxJQUFJO2dCQUN6RSxJQUFJLENBQUN5TSxvQkFBb0JyUyxPQUFPLEVBQUU7b0JBQzlCcVMsb0JBQW9CclMsT0FBTyxHQUFHaVY7Z0JBQ2xDO2dCQUNBLE1BQU1DLGdCQUFnQm5WLFVBQVVDLE9BQU8sQ0FBQ29ILHFCQUFxQixHQUFHQyxHQUFHO2dCQUNuRSw2TEFBNkw7Z0JBQzdMLElBQUlvRSxLQUFLOEQsR0FBRyxDQUFDNEMsd0JBQXdCblMsT0FBTyxHQUFHZ1YsbUJBQW1CLElBQUk7b0JBQ2xFalUsZUFBZWYsT0FBTyxHQUFHLENBQUNlLGVBQWVmLE9BQU87Z0JBQ3BEO2dCQUNBLElBQUlpQixjQUFjQSxXQUFXcU0sTUFBTSxHQUFHLEtBQUt0TSxvQkFBb0J5TSxzQkFBc0I7b0JBQ2pGLE1BQU0wSCx3QkFBd0JuVSxnQkFBZ0IsQ0FBQ3lNLHFCQUFxQixJQUFJO29CQUN4RXVILG1CQUFtQkc7Z0JBQ3ZCO2dCQUNBaEQsd0JBQXdCblMsT0FBTyxHQUFHZ1Y7Z0JBQ2xDLHFLQUFxSztnQkFDckssSUFBSUMsZUFBZUYsd0JBQXdCaFUsZUFBZWYsT0FBTyxFQUFFO29CQUMvRCxNQUFNNEYsU0FBUzdGLFVBQVVDLE9BQU8sQ0FBQ29ILHFCQUFxQixHQUFHeEIsTUFBTTtvQkFDL0QsSUFBSXdQLGtCQUFrQnhQO29CQUN0QixJQUFJQSxTQUFTbVAsc0JBQXNCO3dCQUMvQkssa0JBQWtCTCx1QkFBdUJ6RTtvQkFDN0M7b0JBQ0Esb0pBQW9KO29CQUNwSixJQUFJVyxPQUFPO3dCQUNQbFIsVUFBVUMsT0FBTyxDQUFDZixLQUFLLENBQUMyRyxNQUFNLEdBQUcsQ0FBQyxFQUFFQSxTQUFTNkYsS0FBS2lKLEdBQUcsQ0FBQ00saUJBQWlCLEdBQUcsRUFBRSxDQUFDO29CQUNqRixPQUFPO3dCQUNIalYsVUFBVUMsT0FBTyxDQUFDZixLQUFLLENBQUMyRyxNQUFNLEdBQUcsQ0FBQyxFQUFFNkYsS0FBS2lKLEdBQUcsQ0FBQ1UsaUJBQWlCTCx1QkFBdUJHLGVBQWUsRUFBRSxDQUFDO29CQUMzRztnQkFDSixPQUFPO29CQUNIblYsVUFBVUMsT0FBTyxDQUFDZixLQUFLLENBQUMyRyxNQUFNLEdBQUcsQ0FBQyxFQUFFeU0sb0JBQW9CclMsT0FBTyxDQUFDLEVBQUUsQ0FBQztnQkFDdkU7Z0JBQ0EsSUFBSWlCLGNBQWNBLFdBQVdxTSxNQUFNLEdBQUcsS0FBSyxDQUFDdk0sZUFBZWYsT0FBTyxFQUFFO29CQUNoRUQsVUFBVUMsT0FBTyxDQUFDZixLQUFLLENBQUNpRyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUM7Z0JBQzFDLE9BQU87b0JBQ0gsK0NBQStDO29CQUMvQ25GLFVBQVVDLE9BQU8sQ0FBQ2YsS0FBSyxDQUFDaUcsTUFBTSxHQUFHLENBQUMsRUFBRXVHLEtBQUtpSixHQUFHLENBQUNNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztnQkFDeEU7WUFDSjtRQUNKO1FBQ0NKLENBQUFBLHlCQUF5QmhTLE9BQU9HLGNBQWMsS0FBSyxPQUFPLEtBQUssSUFBSTZSLHVCQUF1QjdPLGdCQUFnQixDQUFDLFVBQVU4TztRQUN0SCxPQUFPO1lBQ0gsSUFBSUQ7WUFDSixPQUFPLENBQUNBLHlCQUF5QmhTLE9BQU9HLGNBQWMsS0FBSyxPQUFPLEtBQUssSUFBSTZSLHVCQUF1QjNOLG1CQUFtQixDQUFDLFVBQVU0TjtRQUNwSTtJQUNKLEdBQUc7UUFDQ3BIO1FBQ0F4TTtRQUNBRDtLQUNIO0lBQ0QsU0FBU1E7UUFDTCxJQUFJLENBQUN6QixVQUFVQyxPQUFPLEVBQUU7UUFDeEJxVjtRQUNBbkUsV0FBVyxPQUFPLEtBQUssSUFBSUE7UUFDM0I5RyxJQUFJckssVUFBVUMsT0FBTyxFQUFFO1lBQ25Cd0YsV0FBV3VGLFdBQVdySixhQUFhLENBQUMsZUFBZSxFQUFFQSxjQUFjLFdBQVcsU0FBUyxRQUFRLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFQSxjQUFjLFVBQVUsU0FBUyxRQUFRLE9BQU8sQ0FBQztZQUN2SzhNLFlBQVksQ0FBQyxVQUFVLEVBQUU3QyxZQUFZQyxRQUFRLENBQUMsZUFBZSxFQUFFRCxZQUFZRSxJQUFJLENBQUM0QyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEc7UUFDQXJFLElBQUluSyxXQUFXRCxPQUFPLEVBQUU7WUFDcEIwTyxTQUFTO1lBQ1RGLFlBQVksQ0FBQyxRQUFRLEVBQUU3QyxZQUFZQyxRQUFRLENBQUMsZUFBZSxFQUFFRCxZQUFZRSxJQUFJLENBQUM0QyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUY7UUFDQXZPLGdCQUFnQjtRQUNoQnVKLFdBQVc7WUFDUGhJLFdBQVc7WUFDWDRQLFVBQVU7UUFDZCxHQUFHO1FBQ0g1SCxXQUFXO1lBQ1AscURBQXFEO1lBQ3JELElBQUl4SSxZQUFZO2dCQUNaSyxtQkFBbUJMLFVBQVUsQ0FBQyxFQUFFO1lBQ3BDO1FBQ0osR0FBRzBLLFlBQVlDLFFBQVEsR0FBRyxPQUFPLGdCQUFnQjtJQUNyRDtJQUNBbE0sNENBQXdCLENBQUM7UUFDckIsSUFBSSxDQUFDbUIsVUFBVThQLHVCQUF1QjtZQUNsQyx3RUFBd0U7WUFDeEUsTUFBTTJFLEtBQUs3TCxXQUFXO2dCQUNsQm1CLE1BQU05TCxTQUFTNkYsSUFBSTtZQUN2QixHQUFHO1lBQ0gsT0FBTyxJQUFJNFEsYUFBYUQ7UUFDNUI7SUFDSixHQUFHO1FBQ0N6VTtRQUNBOFA7S0FDSDtJQUNELG9GQUFvRjtJQUNwRmpSLGtEQUE4QixDQUFDO1FBQzNCLElBQUllLFVBQVU7WUFDVjRRLFVBQVU7WUFDVkMsaUJBQWlCO1FBQ3JCLE9BQU87WUFDSDlQO1FBQ0o7SUFDSixHQUFHO1FBQ0NmO0tBQ0g7SUFDRCwrQkFBK0I7SUFDL0JmLDRDQUF3QixDQUFDO1FBQ3JCLElBQUk2UixTQUFTO1lBQ1RsUSxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWFSO1FBQ2pEO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0RuQiw0Q0FBd0IsQ0FBQztRQUNyQjhSLFdBQVc7SUFDZixHQUFHLEVBQUU7SUFDTCxTQUFTZ0U7UUFDTCxJQUFJLENBQUN6VixVQUFVQyxPQUFPLEVBQUU7UUFDeEIsTUFBTStULFVBQVVqVixTQUFTa1YsYUFBYSxDQUFDO1FBQ3ZDLE1BQU15QixxQkFBcUJ6SyxhQUFhakwsVUFBVUMsT0FBTyxFQUFFMEI7UUFDM0QwSSxJQUFJckssVUFBVUMsT0FBTyxFQUFFO1lBQ25Cd0YsV0FBVztZQUNYZ0osWUFBWSxDQUFDLFVBQVUsRUFBRTdDLFlBQVlDLFFBQVEsQ0FBQyxlQUFlLEVBQUVELFlBQVlFLElBQUksQ0FBQzRDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoRztRQUNBckUsSUFBSW5LLFdBQVdELE9BQU8sRUFBRTtZQUNwQndPLFlBQVksQ0FBQyxRQUFRLEVBQUU3QyxZQUFZQyxRQUFRLENBQUMsZUFBZSxFQUFFRCxZQUFZRSxJQUFJLENBQUM0QyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUZDLFNBQVM7UUFDYjtRQUNBLDJDQUEyQztRQUMzQyxJQUFJaUMseUJBQXlCOEUsc0JBQXNCQSxxQkFBcUIsS0FBSzVVLFFBQVE7WUFDakZ1SixJQUFJMkosU0FBUztnQkFDVFksY0FBYyxDQUFDLEVBQUV2RSxjQUFjLEVBQUUsQ0FBQztnQkFDbENqTixVQUFVO2dCQUNWLEdBQUc0SCxXQUFXckosYUFBYTtvQkFDdkI4RCxXQUFXLENBQUMsTUFBTSxFQUFFa04sV0FBVywwREFBMEQsQ0FBQztvQkFDMUZnRCxpQkFBaUI7Z0JBQ3JCLElBQUk7b0JBQ0FsUSxXQUFXLENBQUMsTUFBTSxFQUFFa04sV0FBVywwREFBMEQsQ0FBQztvQkFDMUZnRCxpQkFBaUI7Z0JBQ3JCLENBQUM7Z0JBQ0RDLG9CQUFvQjtnQkFDcEJDLG9CQUFvQixDQUFDLEVBQUVqSyxZQUFZQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUM5Q2lLLDBCQUEwQixDQUFDLGFBQWEsRUFBRWxLLFlBQVlFLElBQUksQ0FBQzRDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMzRSxHQUFHO1FBQ1A7SUFDSjtJQUNBLFNBQVM0RztRQUNMLElBQUksQ0FBQ3ZVLGNBQWMsQ0FBQ2YsVUFBVUMsT0FBTyxFQUFFO1FBQ3ZDRCxVQUFVQyxPQUFPLENBQUNrVSxTQUFTLENBQUM0QixNQUFNLENBQUN2RjtRQUNuQ3lCLGdCQUFnQmhTLE9BQU8sR0FBRztRQUMxQnlSLGNBQWM7UUFDZEssWUFBWTlSLE9BQU8sR0FBRyxJQUFJc1M7SUFDOUI7SUFDQSxTQUFTbFMsVUFBVTJHLEtBQUs7UUFDcEIsSUFBSSxDQUFDakcsY0FBYyxDQUFDZixVQUFVQyxPQUFPLEVBQUU7UUFDdkNELFVBQVVDLE9BQU8sQ0FBQ2tVLFNBQVMsQ0FBQzRCLE1BQU0sQ0FBQ3ZGO1FBQ25DeUIsZ0JBQWdCaFMsT0FBTyxHQUFHO1FBQzFCeVIsY0FBYztRQUNkSyxZQUFZOVIsT0FBTyxHQUFHLElBQUlzUztRQUMxQixNQUFNZ0IsY0FBY3RJLGFBQWFqTCxVQUFVQyxPQUFPLEVBQUUwQjtRQUNwRCxJQUFJLENBQUNzUixXQUFXak0sTUFBTXJDLE1BQU0sRUFBRSxVQUFVLENBQUM0TyxlQUFlL0YsT0FBT0MsS0FBSyxDQUFDOEYsY0FBYztRQUNuRixJQUFJekIsY0FBYzdSLE9BQU8sS0FBSyxNQUFNO1FBQ3BDLE1BQU0rVixZQUFZakUsWUFBWTlSLE9BQU8sQ0FBQzBULE9BQU8sS0FBSzdCLGNBQWM3UixPQUFPLENBQUMwVCxPQUFPO1FBQy9FLE1BQU1zQyxZQUFZOUQsYUFBYWxTLE9BQU8sR0FBSStLLENBQUFBLFdBQVdySixhQUFhcUYsTUFBTStMLE9BQU8sR0FBRy9MLE1BQU1nTSxPQUFPO1FBQy9GLE1BQU1qRSxXQUFXckQsS0FBSzhELEdBQUcsQ0FBQ3lHLGFBQWFEO1FBQ3ZDLElBQUlqSCxXQUFXLE1BQU07WUFDakIsd0lBQXdJO1lBQ3hJNkMsZ0JBQWdCO1lBQ2hCbEksV0FBVztnQkFDUGtJLGdCQUFnQjtZQUNwQixHQUFHO1FBQ1A7UUFDQSxJQUFJMVEsWUFBWTtZQUNaLE1BQU00UyxzQkFBc0JuUyxjQUFjLFlBQVlBLGNBQWMsVUFBVSxJQUFJLENBQUM7WUFDbkY2USxvQkFBb0I7Z0JBQ2hCMUQsaUJBQWlCbUgsWUFBWW5DO2dCQUM3QnJTO2dCQUNBc047Z0JBQ0FuTztZQUNKO1lBQ0FrUSxpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWM5SixPQUFPO1lBQ3REO1FBQ0o7UUFDQSxtQ0FBbUM7UUFDbkMsSUFBSXJGLGNBQWMsWUFBWUEsY0FBYyxVQUFVc1UsWUFBWSxJQUFJQSxZQUFZLEdBQUc7WUFDakZSO1lBQ0EzRSxpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWM5SixPQUFPO1lBQ3REO1FBQ0o7UUFDQSxJQUFJK0gsV0FBV2hELG9CQUFvQjtZQUMvQnRLO1lBQ0FxUCxpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWM5SixPQUFPO1lBQ3REO1FBQ0o7UUFDQSxJQUFJa1A7UUFDSixNQUFNQyxzQkFBc0J6SyxLQUFLNkksR0FBRyxDQUFDLENBQUMyQixrREFBa0RsVyxVQUFVQyxPQUFPLENBQUNvSCxxQkFBcUIsR0FBR3hCLE1BQU0sS0FBSyxPQUFPcVEsa0RBQWtELEdBQUdyVCxPQUFPaUQsV0FBVztRQUMzTixJQUFJeU4sZUFBZTRDLHNCQUFzQm5GLGdCQUFnQjtZQUNyRHZQO1lBQ0FxUCxpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWM5SixPQUFPO1lBQ3REO1FBQ0o7UUFDQThKLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsY0FBYzlKLE9BQU87UUFDdER5TztJQUNKO0lBQ0E5Viw0Q0FBd0IsQ0FBQztRQUNyQixzREFBc0Q7UUFDdEQsSUFBSW1CLFFBQVE7WUFDUnVKLElBQUl0TCxTQUFTMkUsZUFBZSxFQUFFO2dCQUMxQjBTLGdCQUFnQjtZQUNwQjtZQUNBdkUsU0FBUzVSLE9BQU8sR0FBRyxJQUFJc1M7WUFDdkJwUyxnQkFBZ0I7UUFDcEI7SUFDSixHQUFHO1FBQ0NXO0tBQ0g7SUFDRG5CLDRDQUF3QixDQUFDO1FBQ3JCLElBQUlLLFVBQVVDLE9BQU8sSUFBSXVCLFNBQVM7WUFDOUIsSUFBSTZQO1lBQ0osa0tBQWtLO1lBQ2xLLE1BQU1WLFdBQVczUSxhQUFhLE9BQU8sS0FBSyxJQUFJLENBQUNxUixxQkFBcUJyUixVQUFVQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlvUixtQkFBbUJnRixnQkFBZ0IsQ0FBQztZQUM5STFGLFlBQVksT0FBTyxLQUFLLElBQUlBLFNBQVN4SSxPQUFPLENBQUMsQ0FBQ21PO2dCQUMxQyxNQUFNQyxZQUFZRDtnQkFDbEIsSUFBSUMsVUFBVW5SLFlBQVksR0FBR21SLFVBQVVsUixZQUFZLElBQUlrUixVQUFVQyxXQUFXLEdBQUdELFVBQVVqUyxXQUFXLEVBQUU7b0JBQ2xHaVMsVUFBVXBDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO2dCQUM1QjtZQUNKO1FBQ0o7SUFDSixHQUFHO1FBQ0M1UztLQUNIO0lBQ0QsU0FBU3JCLGdCQUFnQnVRLElBQUk7UUFDekIsTUFBTXNELFVBQVVqVixTQUFTa1YsYUFBYSxDQUFDO1FBQ3ZDLElBQUksQ0FBQ0QsV0FBVyxDQUFDcEQsdUJBQXVCO1FBQ3hDLElBQUlGLE1BQU07WUFDTixJQUFJSywyQkFBMkI7Z0JBQzNCLElBQUksQ0FBQ3BJLGNBQWM7b0JBQ2Ysb0NBQW9DO29CQUNwQzBCLElBQUl0TCxTQUFTNkYsSUFBSSxFQUFFO3dCQUNmNlIsWUFBWTFYLFNBQVM2RixJQUFJLENBQUMxRixLQUFLLENBQUN3WCxlQUFlLElBQUkzWCxTQUFTNkYsSUFBSSxDQUFDMUYsS0FBSyxDQUFDdVgsVUFBVTtvQkFDckY7b0JBQ0EsK0ZBQStGO29CQUMvRnBNLElBQUl0TCxTQUFTNkYsSUFBSSxFQUFFO3dCQUNmNlIsWUFBWTtvQkFDaEIsR0FBRztnQkFDUDtZQUNKO1lBQ0FwTSxJQUFJMkosU0FBUztnQkFDVFksY0FBYyxDQUFDLEVBQUV2RSxjQUFjLEVBQUUsQ0FBQztnQkFDbENqTixVQUFVO2dCQUNWLEdBQUc0SCxXQUFXckosYUFBYTtvQkFDdkI4RCxXQUFXLENBQUMsTUFBTSxFQUFFa04sV0FBVywwREFBMEQsQ0FBQztvQkFDMUZnRCxpQkFBaUI7Z0JBQ3JCLElBQUk7b0JBQ0FsUSxXQUFXLENBQUMsTUFBTSxFQUFFa04sV0FBVywwREFBMEQsQ0FBQztvQkFDMUZnRCxpQkFBaUI7Z0JBQ3JCLENBQUM7Z0JBQ0RDLG9CQUFvQjtnQkFDcEJDLG9CQUFvQixDQUFDLEVBQUVqSyxZQUFZQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUM5Q2lLLDBCQUEwQixDQUFDLGFBQWEsRUFBRWxLLFlBQVlFLElBQUksQ0FBQzRDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMzRTtRQUNKLE9BQU87WUFDSCxPQUFPO1lBQ1A3RCxNQUFNbUosU0FBUztZQUNmbkosTUFBTW1KLFNBQVM7WUFDZm5KLE1BQU1tSixTQUFTO1lBQ2YzSixJQUFJMkosU0FBUztnQkFDVDRCLG9CQUFvQjtnQkFDcEJDLG9CQUFvQixDQUFDLEVBQUVqSyxZQUFZQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUM5Q2lLLDBCQUEwQixDQUFDLGFBQWEsRUFBRWxLLFlBQVlFLElBQUksQ0FBQzRDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMzRTtRQUNKO0lBQ0o7SUFDQSxTQUFTbE8sbUJBQW1CbVcsQ0FBQztRQUN6QixNQUFNQyxRQUFRRCxJQUFJLENBQUM5VCxPQUFPd0IsVUFBVSxHQUFHaU0sbUJBQWtCLElBQUt6TixPQUFPd0IsVUFBVSxHQUFHO1FBQ2xGLE1BQU1ZLElBQUkwUixJQUFJLENBQUNyRyxzQkFBc0I7UUFDckMsSUFBSTRCLHNCQUFzQmpTLE9BQU8sRUFBRTtZQUMvQjRDLE9BQU8yUyxZQUFZLENBQUN0RCxzQkFBc0JqUyxPQUFPO1FBQ3JEO1FBQ0FvSyxJQUFJckssVUFBVUMsT0FBTyxFQUFFO1lBQ25Cd08sWUFBWSxDQUFDLFVBQVUsRUFBRTdDLFlBQVlDLFFBQVEsQ0FBQyxlQUFlLEVBQUVELFlBQVlFLElBQUksQ0FBQzRDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM1RmpKLFdBQVcsQ0FBQyxNQUFNLEVBQUVtUixNQUFNLGlCQUFpQixFQUFFM1IsRUFBRSxNQUFNLENBQUM7UUFDMUQ7UUFDQSxJQUFJLENBQUMwUixLQUFLM1csVUFBVUMsT0FBTyxFQUFFO1lBQ3pCaVMsc0JBQXNCalMsT0FBTyxHQUFHeUosV0FBVztnQkFDdkMsTUFBTTRLLGlCQUFpQnJKLGFBQWFqTCxVQUFVQyxPQUFPLEVBQUUwQjtnQkFDdkQwSSxJQUFJckssVUFBVUMsT0FBTyxFQUFFO29CQUNuQndPLFlBQVk7b0JBQ1poSixXQUFXdUYsV0FBV3JKLGFBQWEsQ0FBQyxlQUFlLEVBQUUyUyxlQUFlLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFQSxlQUFlLFNBQVMsQ0FBQztnQkFDMUg7WUFDSixHQUFHO1FBQ1A7SUFDSjtJQUNBLFNBQVMvVCxhQUFheUcsS0FBSyxFQUFFa0osaUJBQWlCO1FBQzFDLElBQUlBLG9CQUFvQixHQUFHO1FBQzNCLE1BQU0yRyxhQUFhN0wsV0FBV3JKLGFBQWFrQixPQUFPaUQsV0FBVyxHQUFHakQsT0FBT3dCLFVBQVU7UUFDakYsTUFBTXlTLGVBQWUsQ0FBQ0QsYUFBYXZHLG1CQUFrQixJQUFLdUc7UUFDMUQsTUFBTUUsV0FBV0QsZUFBZTVHLG9CQUFxQixLQUFJNEcsWUFBVztRQUNwRSxNQUFNRSxlQUFlLENBQUMxRyxzQkFBc0JKLG9CQUFvQkk7UUFDaEVqRyxJQUFJckssVUFBVUMsT0FBTyxFQUFFO1lBQ25Cd0YsV0FBV3VGLFdBQVdySixhQUFhLENBQUMsTUFBTSxFQUFFb1YsU0FBUyxpQkFBaUIsRUFBRUMsYUFBYSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRUQsU0FBUyxjQUFjLEVBQUVDLGFBQWEsU0FBUyxDQUFDO1lBQ3hKdkksWUFBWTtRQUNoQjtJQUNKO0lBQ0EsU0FBU2hPLGdCQUFnQnVHLEtBQUssRUFBRTJQLENBQUM7UUFDN0IsTUFBTWxILE1BQU16RSxXQUFXckosYUFBYWtCLE9BQU9pRCxXQUFXLEdBQUdqRCxPQUFPd0IsVUFBVTtRQUMxRSxNQUFNdVMsUUFBUUQsSUFBSSxDQUFDbEgsTUFBTWEsbUJBQWtCLElBQUtiLE1BQU07UUFDdEQsTUFBTXdILFlBQVlOLElBQUksQ0FBQ3JHLHNCQUFzQjtRQUM3QyxJQUFJcUcsR0FBRztZQUNIdE0sSUFBSXJLLFVBQVVDLE9BQU8sRUFBRTtnQkFDbkJ3TyxZQUFZLENBQUMsVUFBVSxFQUFFN0MsWUFBWUMsUUFBUSxDQUFDLGVBQWUsRUFBRUQsWUFBWUUsSUFBSSxDQUFDNEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUM1RmpKLFdBQVd1RixXQUFXckosYUFBYSxDQUFDLE1BQU0sRUFBRWlWLE1BQU0saUJBQWlCLEVBQUVLLFVBQVUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUVMLE1BQU0sY0FBYyxFQUFFSyxVQUFVLFNBQVMsQ0FBQztZQUNoSjtRQUNKO0lBQ0o7SUFDQSxPQUFPLFdBQVcsR0FBR3RYLGdEQUE0QixDQUFDRix3REFBb0IsRUFBRTtRQUNwRTBCLE9BQU9BO1FBQ1BHLGNBQWMsQ0FBQ3FWO1lBQ1gsSUFBSWpXLGFBQWFDLFdBQVc7Z0JBQ3hCVyxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWFxVjtnQkFDN0M7WUFDSjtZQUNBLElBQUksQ0FBQ0EsR0FBRztnQkFDSmxWO1lBQ0osT0FBTztnQkFDSDhQLGlCQUFpQjtnQkFDakJELFVBQVVxRjtZQUNkO1FBQ0o7UUFDQWpHLE1BQU01UDtJQUNWLEdBQUcsV0FBVyxHQUFHbkIsZ0RBQTRCLENBQUNHLGNBQWNvWCxRQUFRLEVBQUU7UUFDbEVwUSxPQUFPO1lBQ0h0RjtZQUNBSDtZQUNBSDtZQUNBSztZQUNBdkI7WUFDQUU7WUFDQUM7WUFDQW1CO1lBQ0FsQjtZQUNBc0I7WUFDQXJCO1lBQ0FDO1lBQ0FNO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FLO1lBQ0FLO1lBQ0FsQjtZQUNBQztZQUNBQztZQUNBTztZQUNBTjtZQUNBUztZQUNBRjtZQUNBVTtRQUNKO0lBQ0osR0FBR2dQO0FBQ1A7QUFDQSxNQUFNd0csNEJBQTRCO0FBQ2xDLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxTQUFTLFdBQVcsR0FBRzFYLDZDQUF5QixDQUFDLFNBQVMsRUFBRTRYLGVBQWUsS0FBSyxFQUFFNUcsUUFBUSxFQUFFLEdBQUc2RyxNQUFNLEVBQUV4UCxHQUFHO0lBQzVHLE1BQU0sRUFBRXhHLE9BQU8sRUFBRUMsV0FBVyxFQUFFVixVQUFVLEVBQUVHLFVBQVUsRUFBRUcsZUFBZSxFQUFFRSxrQkFBa0IsRUFBRVgsV0FBVyxFQUFFQyxVQUFVLEVBQUVULE9BQU8sRUFBRUUsTUFBTSxFQUFFLEdBQUdzQjtJQUN4SSxNQUFNNlYsb0JBQW9COVgseUNBQXFCLENBQUM7SUFDaEQsTUFBTStYLDZCQUE2Qi9YLHlDQUFxQixDQUFDO0lBQ3pELFNBQVNnWTtRQUNMLHFEQUFxRDtRQUNyRCxJQUFJRCwyQkFBMkJ6WCxPQUFPLEVBQUU7WUFDcEMyWDtZQUNBO1FBQ0o7UUFDQS9VLE9BQU82RyxVQUFVLENBQUM7WUFDZG1PO1FBQ0osR0FBR1Q7SUFDUDtJQUNBLFNBQVNTO1FBQ0wsZ0RBQWdEO1FBQ2hELElBQUk5VyxjQUFjd1csZ0JBQWdCRywyQkFBMkJ6WCxPQUFPLEVBQUU7WUFDbEUyWDtZQUNBO1FBQ0o7UUFDQSw4RkFBOEY7UUFDOUZBO1FBQ0EsSUFBSSxDQUFDLENBQUMxVyxjQUFjQSxXQUFXcU0sTUFBTSxLQUFLLE1BQU0zTSxhQUFhO1lBQ3pEYTtZQUNBO1FBQ0o7UUFDQSxNQUFNNkwsa0JBQWtCak0sb0JBQW9CSCxVQUFVLENBQUNBLFdBQVdxTSxNQUFNLEdBQUcsRUFBRTtRQUM3RSxJQUFJRCxtQkFBbUIxTSxhQUFhO1lBQ2hDYTtZQUNBO1FBQ0o7UUFDQSxNQUFNcVcsbUJBQW1CNVcsV0FBV3lNLFNBQVMsQ0FBQyxDQUFDb0ssUUFBUUEsVUFBVTFXO1FBQ2pFLElBQUl5VyxxQkFBcUIsQ0FBQyxHQUFHLFFBQVEsMENBQTBDO1FBQy9FLE1BQU1FLGdCQUFnQjlXLFVBQVUsQ0FBQzRXLG1CQUFtQixFQUFFO1FBQ3REdlcsbUJBQW1CeVc7SUFDdkI7SUFDQSxTQUFTQztRQUNMUixrQkFBa0J4WCxPQUFPLEdBQUc0QyxPQUFPNkcsVUFBVSxDQUFDO1lBQzFDLDJDQUEyQztZQUMzQ2dPLDJCQUEyQnpYLE9BQU8sR0FBRztRQUN6QyxHQUFHa1g7SUFDUDtJQUNBLFNBQVNTO1FBQ0wvVSxPQUFPMlMsWUFBWSxDQUFDaUMsa0JBQWtCeFgsT0FBTztRQUM3Q3lYLDJCQUEyQnpYLE9BQU8sR0FBRztJQUN6QztJQUNBLE9BQU8sV0FBVyxHQUFHTixnREFBNEIsQ0FBQyxPQUFPO1FBQ3JEdVksU0FBU1A7UUFDVFEsZUFBZTtZQUNYVCwyQkFBMkJ6WCxPQUFPLEdBQUc7WUFDckN3QjtRQUNKO1FBQ0EyVyxpQkFBaUJSO1FBQ2pCUyxlQUFlLENBQUMzVDtZQUNaLElBQUk3RCxZQUFZVCxRQUFRc0U7WUFDeEJ1VDtRQUNKO1FBQ0FLLGVBQWUsQ0FBQzVUO1lBQ1osSUFBSTdELFlBQVlQLE9BQU9vRTtRQUMzQjtRQUNBLDBEQUEwRDtRQUMxRHNELEtBQUtBO1FBQ0wsdUJBQXVCeEcsVUFBVSxTQUFTO1FBQzFDLGVBQWU7UUFDZixlQUFlO1FBQ2YsR0FBR2dXLElBQUk7SUFDWCxHQUFHLFdBQVcsR0FBRzdYLGdEQUE0QixDQUFDLFFBQVE7UUFDbEQsdUJBQXVCO1FBQ3ZCLGVBQWU7SUFDbkIsR0FBR2dSO0FBQ1A7QUFDQTBHLE9BQU9rQixXQUFXLEdBQUc7QUFDckIsTUFBTUMsVUFBVSxXQUFXLEdBQUc3WSw2Q0FBeUIsQ0FBQyxTQUFTLEVBQUVnUixRQUFRLEVBQUUsR0FBRzZHLE1BQU0sRUFBRXhQLEdBQUc7SUFDdkYsTUFBTSxFQUFFOUgsVUFBVSxFQUFFZ0IsVUFBVSxFQUFFYixTQUFTLEVBQUVlLFVBQVUsRUFBRU4sTUFBTSxFQUFFVSxPQUFPLEVBQUUsR0FBR0k7SUFDM0UsTUFBTTZXLGNBQWNyUSxnQkFBZ0JKLEtBQUs5SDtJQUN6QyxNQUFNd1ksZ0JBQWdCeFgsY0FBY0EsV0FBV3FNLE1BQU0sR0FBRztJQUN4RCxPQUFPLFdBQVcsR0FBRzVOLGdEQUE0QixDQUFDRiwyREFBdUIsRUFBRTtRQUN2RWtaLFdBQVd0WTtRQUNYMkgsS0FBS3lRO1FBQ0wsdUJBQXVCalgsVUFBVSxTQUFTO1FBQzFDLGdCQUFnQjtRQUNoQixvQkFBb0JWLFVBQVU0WCxnQkFBZ0IsU0FBUztRQUN2RCw0QkFBNEI1WCxVQUFVTSxhQUFhLFNBQVM7UUFDNUQsR0FBR29XLElBQUk7SUFDWDtBQUNKO0FBQ0FnQixRQUFRRCxXQUFXLEdBQUc7QUFDdEIsTUFBTUssVUFBVSxXQUFXLEdBQUdqWiw2Q0FBeUIsQ0FBQyxTQUFTLEVBQUVrWixlQUFlLEVBQUVDLG9CQUFvQixFQUFFQyxjQUFjLEVBQUU3WixLQUFLLEVBQUUsR0FBR3NZLE1BQU0sRUFBRXhQLEdBQUc7SUFDM0ksTUFBTSxFQUFFaEksU0FBUyxFQUFFSSxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsTUFBTSxFQUFFTSxXQUFXLEVBQUVJLGNBQWMsRUFBRUMsZ0JBQWdCLEVBQUVPLE9BQU8sRUFBRUMsV0FBVyxFQUFFTixLQUFLLEVBQUVULFFBQVEsRUFBRVksWUFBWSxFQUFFSSxVQUFVLEVBQUViLFVBQVUsRUFBRWMsU0FBUyxFQUFFLEdBQUdDO0lBQ3pMLE1BQU02VyxjQUFjclEsZ0JBQWdCSixLQUFLaEk7SUFDekMsTUFBTWdaLGtCQUFrQnJaLHlDQUFxQixDQUFDO0lBQzlDLE1BQU1zWix1QkFBdUJ0Wix5Q0FBcUIsQ0FBQztJQUNuRCxNQUFNdVoscUJBQXFCLENBQUNDLE9BQU94WCxXQUFXeVgsWUFBWSxDQUFDO1FBQ3ZELElBQUlILHFCQUFxQmhaLE9BQU8sRUFBRSxPQUFPO1FBQ3pDLE1BQU1vWixTQUFTM04sS0FBSzhELEdBQUcsQ0FBQzJKLE1BQU1sVSxDQUFDO1FBQy9CLE1BQU1xVSxTQUFTNU4sS0FBSzhELEdBQUcsQ0FBQzJKLE1BQU1yUCxDQUFDO1FBQy9CLE1BQU15UCxXQUFXRCxTQUFTRDtRQUMxQixNQUFNRyxVQUFVO1lBQ1o7WUFDQTtTQUNILENBQUNDLFFBQVEsQ0FBQzlYLGFBQWEsSUFBSSxDQUFDO1FBQzdCLElBQUlBLGNBQWMsVUFBVUEsY0FBYyxTQUFTO1lBQy9DLE1BQU0rWCxxQkFBcUJQLE1BQU1yUCxDQUFDLEdBQUcwUCxVQUFVO1lBQy9DLElBQUksQ0FBQ0Usc0JBQXNCSixVQUFVLEtBQUtBLFVBQVVGLFdBQVc7Z0JBQzNELE9BQU9HO1lBQ1g7UUFDSixPQUFPO1lBQ0gsTUFBTUcscUJBQXFCUCxNQUFNbFUsQ0FBQyxHQUFHdVUsVUFBVTtZQUMvQyxJQUFJLENBQUNFLHNCQUFzQkwsVUFBVSxLQUFLQSxVQUFVRCxXQUFXO2dCQUMzRCxPQUFPLENBQUNHO1lBQ1o7UUFDSjtRQUNBTixxQkFBcUJoWixPQUFPLEdBQUc7UUFDL0IsT0FBTztJQUNYO0lBQ0FOLDRDQUF3QixDQUFDO1FBQ3JCLHNEQUFzRDtRQUN0RCtCLFdBQVc7SUFDZixHQUFHLEVBQUU7SUFDTCxPQUFPLFdBQVcsR0FBRy9CLGdEQUE0QixDQUFDRiwyREFBdUIsRUFBRTtRQUN2RSxlQUFlO1FBQ2YseUJBQXlCa0M7UUFDekIsdUJBQXVCSCxVQUFVLFNBQVM7UUFDMUMsR0FBR2dXLElBQUk7UUFDUHhQLEtBQUt5UTtRQUNMdlosT0FBTytCLG9CQUFvQkEsaUJBQWlCc00sTUFBTSxHQUFHLElBQUk7WUFDckQsdUJBQXVCLENBQUMsRUFBRXRNLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDakQsR0FBRy9CLEtBQUs7UUFDWixJQUFJQTtRQUNKMlosaUJBQWlCLENBQUNuVTtZQUNkLElBQUltVSxpQkFBaUI7Z0JBQ2pCQSxnQkFBZ0JuVTtZQUNwQixPQUFPO2dCQUNILElBQUkyTTtnQkFDSjNNLEVBQUVNLGNBQWM7Z0JBQ2ZxTSxDQUFBQSxxQkFBcUJyUixVQUFVQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlvUixtQkFBbUIzTCxLQUFLO1lBQ3hGO1FBQ0o7UUFDQTJTLGVBQWUsQ0FBQ3JSO1lBQ1osSUFBSW5HLFlBQVk7WUFDaEIyVyxLQUFLYSxhQUFhLElBQUksT0FBTyxLQUFLLElBQUliLEtBQUthLGFBQWEsQ0FBQ2xNLElBQUksQ0FBQ3FMLE1BQU14UTtZQUNwRWdTLGdCQUFnQi9ZLE9BQU8sR0FBRztnQkFDdEI2SixHQUFHOUMsTUFBTWdNLE9BQU87Z0JBQ2hCL04sR0FBRytCLE1BQU0rTCxPQUFPO1lBQ3BCO1lBQ0EzUyxRQUFRNEc7UUFDWjtRQUNBOFIsc0JBQXNCLENBQUNwVTtZQUNuQm9VLHdCQUF3QixPQUFPLEtBQUssSUFBSUEscUJBQXFCcFU7WUFDN0QsSUFBSSxDQUFDdkQsU0FBU3VELEVBQUVpVixnQkFBZ0IsRUFBRTtnQkFDOUJqVixFQUFFTSxjQUFjO2dCQUNoQjtZQUNKO1lBQ0EsSUFBSWhFLGVBQWVmLE9BQU8sRUFBRTtnQkFDeEJlLGVBQWVmLE9BQU8sR0FBRztZQUM3QjtZQUNBeUUsRUFBRU0sY0FBYztZQUNoQjFELGdCQUFnQixPQUFPLEtBQUssSUFBSUEsYUFBYTtZQUM3QyxJQUFJLENBQUNWLGVBQWVGLGFBQWFDLFdBQVc7Z0JBQ3hDO1lBQ0o7WUFDQWM7UUFDSjtRQUNBbVksZ0JBQWdCLENBQUNsVjtZQUNiLElBQUksQ0FBQ3ZELE9BQU87Z0JBQ1J1RCxFQUFFTSxjQUFjO2dCQUNoQjtZQUNKO1FBQ0o7UUFDQTZVLGlCQUFpQixDQUFDblY7WUFDZCxJQUFJLENBQUN2RCxPQUFPO2dCQUNSdUQsRUFBRU0sY0FBYztnQkFDaEI7WUFDSjtRQUNKO1FBQ0FzVCxlQUFlLENBQUN0UjtZQUNaLElBQUluRyxZQUFZO1lBQ2hCMlcsS0FBS2MsYUFBYSxJQUFJLE9BQU8sS0FBSyxJQUFJZCxLQUFLYyxhQUFhLENBQUNuTSxJQUFJLENBQUNxTCxNQUFNeFE7WUFDcEUsSUFBSSxDQUFDZ1MsZ0JBQWdCL1ksT0FBTyxFQUFFO1lBQzlCLE1BQU02WixZQUFZOVMsTUFBTStMLE9BQU8sR0FBR2lHLGdCQUFnQi9ZLE9BQU8sQ0FBQ2dGLENBQUM7WUFDM0QsTUFBTThVLFlBQVkvUyxNQUFNZ00sT0FBTyxHQUFHZ0csZ0JBQWdCL1ksT0FBTyxDQUFDNkosQ0FBQztZQUMzRCxNQUFNa1Esc0JBQXNCaFQsTUFBTWlULFdBQVcsS0FBSyxVQUFVLEtBQUs7WUFDakUsTUFBTWQsUUFBUTtnQkFDVnJQLEdBQUdpUTtnQkFDSDlVLEdBQUc2VTtZQUNQO1lBQ0EsTUFBTUksbUJBQW1CaEIsbUJBQW1CQyxPQUFPeFgsV0FBV3FZO1lBQzlELElBQUlFLGtCQUFrQjVaLE9BQU8wRztpQkFDeEIsSUFBSTBFLEtBQUs4RCxHQUFHLENBQUN1SyxhQUFhQyx1QkFBdUJ0TyxLQUFLOEQsR0FBRyxDQUFDc0ssYUFBYUUscUJBQXFCO2dCQUM3RmhCLGdCQUFnQi9ZLE9BQU8sR0FBRztZQUM5QjtRQUNKO1FBQ0FrYSxhQUFhLENBQUNuVDtZQUNWd1EsS0FBSzJDLFdBQVcsSUFBSSxPQUFPLEtBQUssSUFBSTNDLEtBQUsyQyxXQUFXLENBQUNoTyxJQUFJLENBQUNxTCxNQUFNeFE7WUFDaEVnUyxnQkFBZ0IvWSxPQUFPLEdBQUc7WUFDMUJnWixxQkFBcUJoWixPQUFPLEdBQUc7WUFDL0JJLFVBQVUyRztRQUNkO0lBQ0o7QUFDSjtBQUNBNFIsUUFBUUwsV0FBVyxHQUFHO0FBQ3RCLFNBQVM2QixXQUFXLEVBQUU5WixNQUFNLEVBQUVnQixZQUFZLEVBQUUsR0FBR2tXLE1BQU07SUFDakQsTUFBTSxFQUFFalgsWUFBWSxFQUFFQyxrQkFBa0IsRUFBRUMsZUFBZSxFQUFFLEdBQUdtQjtJQUM5RCxJQUFJLENBQUNyQixjQUFjO1FBQ2YsTUFBTSxJQUFJd0IsTUFBTTtJQUNwQjtJQUNBLE9BQU8sV0FBVyxHQUFHcEMsZ0RBQTRCLENBQUM4USxNQUFNO1FBQ3BEakksUUFBUTtRQUNSMkksU0FBUztZQUNMM1EsbUJBQW1CO1FBQ3ZCO1FBQ0FGLFFBQVEsQ0FBQ29FLEdBQUcyVjtZQUNSOVosYUFBYW1FLEdBQUcyVjtZQUNoQi9aLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9vRSxHQUFHMlY7UUFDeEM7UUFDQS9ZLGNBQWMsQ0FBQ3FWO1lBQ1gsSUFBSUEsR0FBRztnQkFDSG5XLG1CQUFtQm1XO1lBQ3ZCO1lBQ0FyVixnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWFxVjtRQUNqRDtRQUNBdFcsV0FBV0k7UUFDWCxHQUFHK1csSUFBSTtJQUNYO0FBQ0o7QUFDQSxNQUFNOEMsU0FBUztJQUNYN0o7SUFDQTJKO0lBQ0F4QjtJQUNBdkI7SUFDQW1CO0lBQ0ErQixTQUFTOWEsMkRBQXVCO0lBQ2hDK2EsUUFBUS9hLDBEQUFzQjtJQUM5QmdiLE9BQU9oYix5REFBcUI7SUFDNUJpYixPQUFPamIseURBQXFCO0lBQzVCa2IsYUFBYWxiLCtEQUEyQjtBQUM1QztBQUVrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhYXMtdGVtcGxhdGUtbWFnaWN1aS8uL25vZGVfbW9kdWxlcy8ucG5wbS92YXVsQDAuOS4xX0B0eXBlcytyZWFjdC1kb21AMTguMy4wX0B0eXBlcytyZWFjdEAxOC4zLjNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvdmF1bC9kaXN0L2luZGV4Lm1qcz8wMzg4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmZ1bmN0aW9uIF9faW5zZXJ0Q1NTKGNvZGUpIHtcbiAgaWYgKCFjb2RlIHx8IHR5cGVvZiBkb2N1bWVudCA9PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gIGxldCBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSlcbiAgO3N0eWxlLnN0eWxlU2hlZXQgPyAoc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29kZSkgOiBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb2RlKSlcbn1cblxuaW1wb3J0ICogYXMgRGlhbG9nUHJpbWl0aXZlIGZyb20gJ0ByYWRpeC11aS9yZWFjdC1kaWFsb2cnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBEcmF3ZXJDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCh7XG4gICAgZHJhd2VyUmVmOiB7XG4gICAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICB9LFxuICAgIG92ZXJsYXlSZWY6IHtcbiAgICAgICAgY3VycmVudDogbnVsbFxuICAgIH0sXG4gICAgc2NhbGVCYWNrZ3JvdW5kOiAoKT0+e30sXG4gICAgb25QcmVzczogKCk9Pnt9LFxuICAgIG9uUmVsZWFzZTogKCk9Pnt9LFxuICAgIG9uRHJhZzogKCk9Pnt9LFxuICAgIG9uTmVzdGVkRHJhZzogKCk9Pnt9LFxuICAgIG9uTmVzdGVkT3BlbkNoYW5nZTogKCk9Pnt9LFxuICAgIG9uTmVzdGVkUmVsZWFzZTogKCk9Pnt9LFxuICAgIG9wZW5Qcm9wOiB1bmRlZmluZWQsXG4gICAgZGlzbWlzc2libGU6IGZhbHNlLFxuICAgIGhhbmRsZU9ubHk6IGZhbHNlLFxuICAgIGlzT3BlbjogZmFsc2UsXG4gICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAga2V5Ym9hcmRJc09wZW46IHtcbiAgICAgICAgY3VycmVudDogZmFsc2VcbiAgICB9LFxuICAgIHNuYXBQb2ludHNPZmZzZXQ6IG51bGwsXG4gICAgc25hcFBvaW50czogbnVsbCxcbiAgICBtb2RhbDogZmFsc2UsXG4gICAgc2hvdWxkRmFkZTogZmFsc2UsXG4gICAgYWN0aXZlU25hcFBvaW50OiBudWxsLFxuICAgIG9uT3BlbkNoYW5nZTogKCk9Pnt9LFxuICAgIHNldEFjdGl2ZVNuYXBQb2ludDogKCk9Pnt9LFxuICAgIHZpc2libGU6IGZhbHNlLFxuICAgIGNsb3NlRHJhd2VyOiAoKT0+e30sXG4gICAgc2V0VmlzaWJsZTogKCk9Pnt9LFxuICAgIGRpcmVjdGlvbjogJ2JvdHRvbSdcbn0pO1xuY29uc3QgdXNlRHJhd2VyQ29udGV4dCA9ICgpPT57XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoRHJhd2VyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlRHJhd2VyQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgRHJhd2VyLlJvb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5fX2luc2VydENTUyhcIlt2YXVsLWRyYXdlcl17dG91Y2gtYWN0aW9uOm5vbmU7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtO3RyYW5zaXRpb246dHJhbnNmb3JtIC41cyBjdWJpYy1iZXppZXIoLjMyLCAuNzIsIDAsIDEpfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWJvdHRvbV17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMTAwJSwwKX1bdmF1bC1kcmF3ZXJdW3ZhdWwtZHJhd2VyLWRpcmVjdGlvbj10b3Bde3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC0xMDAlLDApfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWxlZnRde3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTAwJSwwLDApfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPXJpZ2h0XXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTAwJSwwLDApfS52YXVsLWRyYWdnaW5nIC52YXVsLXNjcm9sbGFibGUgW3ZhdWx0LWRyYXdlci1kaXJlY3Rpb249dG9wXXtvdmVyZmxvdy15OmhpZGRlbiFpbXBvcnRhbnR9LnZhdWwtZHJhZ2dpbmcgLnZhdWwtc2Nyb2xsYWJsZSBbdmF1bHQtZHJhd2VyLWRpcmVjdGlvbj1ib3R0b21de292ZXJmbG93LXk6aGlkZGVuIWltcG9ydGFudH0udmF1bC1kcmFnZ2luZyAudmF1bC1zY3JvbGxhYmxlIFt2YXVsdC1kcmF3ZXItZGlyZWN0aW9uPWxlZnRde292ZXJmbG93LXg6aGlkZGVuIWltcG9ydGFudH0udmF1bC1kcmFnZ2luZyAudmF1bC1zY3JvbGxhYmxlIFt2YXVsdC1kcmF3ZXItZGlyZWN0aW9uPXJpZ2h0XXtvdmVyZmxvdy14OmhpZGRlbiFpbXBvcnRhbnR9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci12aXNpYmxlPXRydWVdW3ZhdWwtZHJhd2VyLWRpcmVjdGlvbj10b3Bde3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLHZhcigtLXNuYXAtcG9pbnQtaGVpZ2h0LDApLDApfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItdmlzaWJsZT10cnVlXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249Ym90dG9tXXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS1zbmFwLXBvaW50LWhlaWdodCwwKSwwKX1bdmF1bC1kcmF3ZXJdW3ZhdWwtZHJhd2VyLXZpc2libGU9dHJ1ZV1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWxlZnRde3RyYW5zZm9ybTp0cmFuc2xhdGUzZCh2YXIoLS1zbmFwLXBvaW50LWhlaWdodCwwKSwwLDApfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItdmlzaWJsZT10cnVlXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249cmlnaHRde3RyYW5zZm9ybTp0cmFuc2xhdGUzZCh2YXIoLS1zbmFwLXBvaW50LWhlaWdodCwwKSwwLDApfVt2YXVsLW92ZXJsYXlde29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjVzIGN1YmljLWJlemllciguMzIsIC43MiwgMCwgMSl9W3ZhdWwtb3ZlcmxheV1bdmF1bC1kcmF3ZXItdmlzaWJsZT10cnVlXXtvcGFjaXR5OjF9W3ZhdWwtZHJhd2VyXTo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOmluaGVyaXQ7YmFja2dyb3VuZC1jb2xvcjppbmhlcml0fVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPXRvcF06OmFmdGVye3RvcDppbml0aWFsO2JvdHRvbToxMDAlO2xlZnQ6MDtyaWdodDowO2hlaWdodDoyMDAlfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWJvdHRvbV06OmFmdGVye3RvcDoxMDAlO2JvdHRvbTppbml0aWFsO2xlZnQ6MDtyaWdodDowO2hlaWdodDoyMDAlfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWxlZnRdOjphZnRlcntsZWZ0OmluaXRpYWw7cmlnaHQ6MTAwJTt0b3A6MDtib3R0b206MDt3aWR0aDoyMDAlfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPXJpZ2h0XTo6YWZ0ZXJ7bGVmdDoxMDAlO3JpZ2h0OmluaXRpYWw7dG9wOjA7Ym90dG9tOjA7d2lkdGg6MjAwJX1bdmF1bC1oYW5kbGVde2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7b3BhY2l0eTouODttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvO2hlaWdodDo1cHg7d2lkdGg6NTZweDtib3JkZXItcmFkaXVzOjFyZW07dG91Y2gtYWN0aW9uOnBhbi15O2N1cnNvcjpncmFifVt2YXVsLWhhbmRsZV06YWN0aXZlLFt2YXVsLWhhbmRsZV06aG92ZXJ7b3BhY2l0eToxfVt2YXVsLWhhbmRsZV06YWN0aXZle2N1cnNvcjpncmFiYmluZ31bdmF1bC1oYW5kbGUtaGl0YXJlYV17cG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7d2lkdGg6bWF4KDEwMCUsMi43NXJlbSk7aGVpZ2h0Om1heCgxMDAlLDIuNzVyZW0pO3RvdWNoLWFjdGlvbjppbmhlcml0fVt2YXVsLW92ZXJsYXldW3ZhdWwtc25hcC1wb2ludHM9dHJ1ZV06bm90KFt2YXVsLXNuYXAtcG9pbnRzLW92ZXJsYXk9dHJ1ZV0pOm5vdChbZGF0YS1zdGF0ZT1jbG9zZWRdKXtvcGFjaXR5OjB9W3ZhdWwtb3ZlcmxheV1bdmF1bC1zbmFwLXBvaW50cy1vdmVybGF5PXRydWVdOm5vdChbdmF1bC1kcmF3ZXItdmlzaWJsZT1mYWxzZV0pe29wYWNpdHk6MX1AbWVkaWEgKGhvdmVyOmhvdmVyKSBhbmQgKHBvaW50ZXI6ZmluZSl7W3ZhdWwtZHJhd2VyXXt1c2VyLXNlbGVjdDpub25lfX1AbWVkaWEgKHBvaW50ZXI6ZmluZSl7W3ZhdWwtaGFuZGxlLWhpdGFyZWFdOnt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfX1cIik7XG5cbi8vIFRoaXMgY29kZSBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9ibG9iL21haW4vcGFja2FnZXMvJTQwcmVhY3QtYXJpYS9vdmVybGF5cy9zcmMvdXNlUHJldmVudFNjcm9sbC50c1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuZnVuY3Rpb24gY2hhaW4oLi4uY2FsbGJhY2tzKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKT0+e1xuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBjYWxsYmFja3Mpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzTWFjKCkge1xuICAgIHJldHVybiB0ZXN0UGxhdGZvcm0oL15NYWMvKTtcbn1cbmZ1bmN0aW9uIGlzSVBob25lKCkge1xuICAgIHJldHVybiB0ZXN0UGxhdGZvcm0oL15pUGhvbmUvKTtcbn1cbmZ1bmN0aW9uIGlzSVBhZCgpIHtcbiAgICByZXR1cm4gdGVzdFBsYXRmb3JtKC9eaVBhZC8pIHx8IC8vIGlQYWRPUyAxMyBsaWVzIGFuZCBzYXlzIGl0J3MgYSBNYWMsIGJ1dCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYnkgZGV0ZWN0aW5nIHRvdWNoIHN1cHBvcnQuXG4gICAgaXNNYWMoKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xufVxuZnVuY3Rpb24gaXNJT1MoKSB7XG4gICAgcmV0dXJuIGlzSVBob25lKCkgfHwgaXNJUGFkKCk7XG59XG5mdW5jdGlvbiB0ZXN0UGxhdGZvcm0ocmUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvciAhPSBudWxsID8gcmUudGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSA6IHVuZGVmaW5lZDtcbn1cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG5mdW5jdGlvbiBpc1Njcm9sbGFibGUobm9kZSkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIHJldHVybiAvKGF1dG98c2Nyb2xsKS8udGVzdChzdHlsZS5vdmVyZmxvdyArIHN0eWxlLm92ZXJmbG93WCArIHN0eWxlLm92ZXJmbG93WSk7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICAgIGlmIChpc1Njcm9sbGFibGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgd2hpbGUobm9kZSAmJiAhaXNTY3JvbGxhYmxlKG5vZGUpKXtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUgfHwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG4vLyBIVE1MIGlucHV0IHR5cGVzIHRoYXQgZG8gbm90IGNhdXNlIHRoZSBzb2Z0d2FyZSBrZXlib2FyZCB0byBhcHBlYXIuXG5jb25zdCBub25UZXh0SW5wdXRUeXBlcyA9IG5ldyBTZXQoW1xuICAgICdjaGVja2JveCcsXG4gICAgJ3JhZGlvJyxcbiAgICAncmFuZ2UnLFxuICAgICdjb2xvcicsXG4gICAgJ2ZpbGUnLFxuICAgICdpbWFnZScsXG4gICAgJ2J1dHRvbicsXG4gICAgJ3N1Ym1pdCcsXG4gICAgJ3Jlc2V0J1xuXSk7XG4vLyBUaGUgbnVtYmVyIG9mIGFjdGl2ZSB1c2VQcmV2ZW50U2Nyb2xsIGNhbGxzLiBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBwYWdlIHN0eWxlL3Njcm9sbCBwb3NpdGlvblxubGV0IHByZXZlbnRTY3JvbGxDb3VudCA9IDA7XG5sZXQgcmVzdG9yZTtcbi8qKlxuICogUHJldmVudHMgc2Nyb2xsaW5nIG9uIHRoZSBkb2N1bWVudCBib2R5IG9uIG1vdW50LCBhbmRcbiAqIHJlc3RvcmVzIGl0IG9uIHVubW91bnQuIEFsc28gZW5zdXJlcyB0aGF0IGNvbnRlbnQgZG9lcyBub3RcbiAqIHNoaWZ0IGR1ZSB0byB0aGUgc2Nyb2xsYmFycyBkaXNhcHBlYXJpbmcuXG4gKi8gZnVuY3Rpb24gdXNlUHJldmVudFNjcm9sbChvcHRpb25zID0ge30pIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkIH0gPSBvcHRpb25zO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ZW50U2Nyb2xsQ291bnQrKztcbiAgICAgICAgaWYgKHByZXZlbnRTY3JvbGxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlID0gcHJldmVudFNjcm9sbE1vYmlsZVNhZmFyaSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlID0gcHJldmVudFNjcm9sbFN0YW5kYXJkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50U2Nyb2xsQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkXG4gICAgXSk7XG59XG4vLyBGb3IgbW9zdCBicm93c2VycywgYWxsIHdlIG5lZWQgdG8gZG8gaXMgc2V0IGBvdmVyZmxvdzogaGlkZGVuYCBvbiB0aGUgcm9vdCBlbGVtZW50LCBhbmRcbi8vIGFkZCBzb21lIHBhZGRpbmcgdG8gcHJldmVudCB0aGUgcGFnZSBmcm9tIHNoaWZ0aW5nIHdoZW4gdGhlIHNjcm9sbGJhciBpcyBoaWRkZW4uXG5mdW5jdGlvbiBwcmV2ZW50U2Nyb2xsU3RhbmRhcmQoKSB7XG4gICAgcmV0dXJuIGNoYWluKHNldFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ3BhZGRpbmdSaWdodCcsIGAke3dpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofXB4YCkpO1xufVxuLy8gTW9iaWxlIFNhZmFyaSBpcyBhIHdob2xlIGRpZmZlcmVudCBiZWFzdC4gRXZlbiB3aXRoIG92ZXJmbG93OiBoaWRkZW4sXG4vLyBpdCBzdGlsbCBzY3JvbGxzIHRoZSBwYWdlIGluIG1hbnkgc2l0dWF0aW9uczpcbi8vXG4vLyAxLiBXaGVuIHRoZSBib3R0b20gdG9vbGJhciBhbmQgYWRkcmVzcyBiYXIgYXJlIGNvbGxhcHNlZCwgcGFnZSBzY3JvbGxpbmcgaXMgYWx3YXlzIGFsbG93ZWQuXG4vLyAyLiBXaGVuIHRoZSBrZXlib2FyZCBpcyB2aXNpYmxlLCB0aGUgdmlld3BvcnQgZG9lcyBub3QgcmVzaXplLiBJbnN0ZWFkLCB0aGUga2V5Ym9hcmQgY292ZXJzIHBhcnQgb2Zcbi8vICAgIGl0LCBzbyBpdCBiZWNvbWVzIHNjcm9sbGFibGUuXG4vLyAzLiBXaGVuIHRhcHBpbmcgb24gYW4gaW5wdXQsIHRoZSBwYWdlIGFsd2F5cyBzY3JvbGxzIHNvIHRoYXQgdGhlIGlucHV0IGlzIGNlbnRlcmVkIGluIHRoZSB2aXN1YWwgdmlld3BvcnQuXG4vLyAgICBUaGlzIG1heSBjYXVzZSBldmVuIGZpeGVkIHBvc2l0aW9uIGVsZW1lbnRzIHRvIHNjcm9sbCBvZmYgdGhlIHNjcmVlbi5cbi8vIDQuIFdoZW4gdXNpbmcgdGhlIG5leHQvcHJldmlvdXMgYnV0dG9ucyBpbiB0aGUga2V5Ym9hcmQgdG8gbmF2aWdhdGUgYmV0d2VlbiBpbnB1dHMsIHRoZSB3aG9sZSBwYWdlIGFsd2F5c1xuLy8gICAgc2Nyb2xscywgZXZlbiBpZiB0aGUgaW5wdXQgaXMgaW5zaWRlIGEgbmVzdGVkIHNjcm9sbGFibGUgZWxlbWVudCB0aGF0IGNvdWxkIGJlIHNjcm9sbGVkIGluc3RlYWQuXG4vL1xuLy8gSW4gb3JkZXIgdG8gd29yayBhcm91bmQgdGhlc2UgY2FzZXMsIGFuZCBwcmV2ZW50IHNjcm9sbGluZyB3aXRob3V0IGphbmtpbmVzcywgd2UgZG8gYSBmZXcgdGhpbmdzOlxuLy9cbi8vIDEuIFByZXZlbnQgZGVmYXVsdCBvbiBgdG91Y2htb3ZlYCBldmVudHMgdGhhdCBhcmUgbm90IGluIGEgc2Nyb2xsYWJsZSBlbGVtZW50LiBUaGlzIHByZXZlbnRzIHRvdWNoIHNjcm9sbGluZ1xuLy8gICAgb24gdGhlIHdpbmRvdy5cbi8vIDIuIFByZXZlbnQgZGVmYXVsdCBvbiBgdG91Y2htb3ZlYCBldmVudHMgaW5zaWRlIGEgc2Nyb2xsYWJsZSBlbGVtZW50IHdoZW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBhdCB0aGVcbi8vICAgIHRvcCBvciBib3R0b20uIFRoaXMgYXZvaWRzIHRoZSB3aG9sZSBwYWdlIHNjcm9sbGluZyBpbnN0ZWFkLCBidXQgZG9lcyBwcmV2ZW50IG92ZXJzY3JvbGxpbmcuXG4vLyAzLiBQcmV2ZW50IGRlZmF1bHQgb24gYHRvdWNoZW5kYCBldmVudHMgb24gaW5wdXQgZWxlbWVudHMgYW5kIGhhbmRsZSBmb2N1c2luZyB0aGUgZWxlbWVudCBvdXJzZWx2ZXMuXG4vLyA0LiBXaGVuIGZvY3VzaW5nIGFuIGlucHV0LCBhcHBseSBhIHRyYW5zZm9ybSB0byB0cmljayBTYWZhcmkgaW50byB0aGlua2luZyB0aGUgaW5wdXQgaXMgYXQgdGhlIHRvcFxuLy8gICAgb2YgdGhlIHBhZ2UsIHdoaWNoIHByZXZlbnRzIGl0IGZyb20gc2Nyb2xsaW5nIHRoZSBwYWdlLiBBZnRlciB0aGUgaW5wdXQgaXMgZm9jdXNlZCwgc2Nyb2xsIHRoZSBlbGVtZW50XG4vLyAgICBpbnRvIHZpZXcgb3Vyc2VsdmVzLCB3aXRob3V0IHNjcm9sbGluZyB0aGUgd2hvbGUgcGFnZS5cbi8vIDUuIE9mZnNldCB0aGUgYm9keSBieSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHVzaW5nIGEgbmVnYXRpdmUgbWFyZ2luIGFuZCBzY3JvbGwgdG8gdGhlIHRvcC4gVGhpcyBzaG91bGQgYXBwZWFyIHRoZVxuLy8gICAgc2FtZSB2aXN1YWxseSwgYnV0IG1ha2VzIHRoZSBhY3R1YWwgc2Nyb2xsIHBvc2l0aW9uIGFsd2F5cyB6ZXJvLiBUaGlzIGlzIHJlcXVpcmVkIHRvIG1ha2UgYWxsIG9mIHRoZVxuLy8gICAgYWJvdmUgd29yayBvciBTYWZhcmkgd2lsbCBzdGlsbCB0cnkgdG8gc2Nyb2xsIHRoZSBwYWdlIHdoZW4gZm9jdXNpbmcgYW4gaW5wdXQuXG4vLyA2LiBBcyBhIGxhc3QgcmVzb3J0LCBoYW5kbGUgd2luZG93IHNjcm9sbCBldmVudHMsIGFuZCBzY3JvbGwgYmFjayB0byB0aGUgdG9wLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhdHRlbXB0aW5nXG4vLyAgICB0byBuYXZpZ2F0ZSB0byBhbiBpbnB1dCB3aXRoIHRoZSBuZXh0L3ByZXZpb3VzIGJ1dHRvbnMgdGhhdCdzIG91dHNpZGUgYSBtb2RhbC5cbmZ1bmN0aW9uIHByZXZlbnRTY3JvbGxNb2JpbGVTYWZhcmkoKSB7XG4gICAgbGV0IHNjcm9sbGFibGU7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgb25Ub3VjaFN0YXJ0ID0gKGUpPT57XG4gICAgICAgIC8vIFN0b3JlIHRoZSBuZWFyZXN0IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnQgZnJvbSB0aGUgZWxlbWVudCB0aGF0IHRoZSB1c2VyIHRvdWNoZWQuXG4gICAgICAgIHNjcm9sbGFibGUgPSBnZXRTY3JvbGxQYXJlbnQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoc2Nyb2xsYWJsZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WSA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgfTtcbiAgICBsZXQgb25Ub3VjaE1vdmUgPSAoZSk9PntcbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgdGhlIHdpbmRvdy5cbiAgICAgICAgaWYgKCFzY3JvbGxhYmxlIHx8IHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBzY3JvbGxhYmxlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgdXAgd2hlbiBhdCB0aGUgdG9wIGFuZCBzY3JvbGxpbmcgZG93biB3aGVuIGF0IHRoZSBib3R0b21cbiAgICAgICAgLy8gb2YgYSBuZXN0ZWQgc2Nyb2xsYWJsZSBhcmVhLCBvdGhlcndpc2UgbW9iaWxlIFNhZmFyaSB3aWxsIHN0YXJ0IHNjcm9sbGluZ1xuICAgICAgICAvLyB0aGUgd2luZG93IGluc3RlYWQuIFVuZm9ydHVuYXRlbHksIHRoaXMgZGlzYWJsZXMgYm91bmNlIHNjcm9sbGluZyB3aGVuIGF0XG4gICAgICAgIC8vIHRoZSB0b3AgYnV0IGl0J3MgdGhlIGJlc3Qgd2UgY2FuIGRvLlxuICAgICAgICBsZXQgeSA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBzY3JvbGxhYmxlLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsYWJsZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChib3R0b20gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsVG9wIDw9IDAgJiYgeSA+IGxhc3RZIHx8IHNjcm9sbFRvcCA+PSBib3R0b20gJiYgeSA8IGxhc3RZKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFkgPSB5O1xuICAgIH07XG4gICAgbGV0IG9uVG91Y2hFbmQgPSAoZSk9PntcbiAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAvLyBBcHBseSB0aGlzIGNoYW5nZSBpZiB3ZSdyZSBub3QgYWxyZWFkeSBmb2N1c2VkIG9uIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICBpZiAoaXNJbnB1dCh0YXJnZXQpICYmIHRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gQXBwbHkgYSB0cmFuc2Zvcm0gdG8gdHJpY2sgU2FmYXJpIGludG8gdGhpbmtpbmcgdGhlIGlucHV0IGlzIGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgdHJ5IHRvIHNjcm9sbCBpdCBpbnRvIHZpZXcuIFdoZW4gdGFwcGluZyBvbiBhbiBpbnB1dCwgdGhpcyBuZWVkcyB0b1xuICAgICAgICAgICAgLy8gYmUgZG9uZSBiZWZvcmUgdGhlIFwiZm9jdXNcIiBldmVudCwgc28gd2UgaGF2ZSB0byBmb2N1cyB0aGUgZWxlbWVudCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoLTIwMDBweCknO1xuICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IG9uRm9jdXMgPSAoZSk9PntcbiAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoaXNJbnB1dCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYWxzbyBuZWVkcyB0byBiZSBhcHBsaWVkIGluIHRoZSBmb2N1cyBldmVudCBpbiBjYXNlcyB3aGVyZSBmb2N1cyBtb3Zlc1xuICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiB0YXBwaW5nIG9uIGFuIGlucHV0IGRpcmVjdGx5LCBlLmcuIHRoZSBuZXh0L3ByZXZpb3VzIGJ1dHRvbnMgaW4gdGhlXG4gICAgICAgICAgICAvLyBzb2Z0d2FyZSBrZXlib2FyZC4gSW4gdGhlc2UgY2FzZXMsIGl0IHNlZW1zIGFwcGx5aW5nIHRoZSB0cmFuc2Zvcm0gaW4gdGhlIGZvY3VzIGV2ZW50XG4gICAgICAgICAgICAvLyBpcyBnb29kIGVub3VnaCwgd2hlcmVhcyB3aGVuIHRhcHBpbmcgYW4gaW5wdXQsIGl0IG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIGZvY3VzIGV2ZW50LiDwn6S34oCN4pmC77iPXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoLTIwMDBweCknO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBoYXZlIHByZXZlbnRlZCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyB0aGUgZm9jdXNlZCBlbGVtZW50IGludG8gdmlldyxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRvIHRoaXMgb3Vyc2VsdmVzIGluIGEgd2F5IHRoYXQgZG9lc24ndCBjYXVzZSB0aGUgd2hvbGUgcGFnZSB0byBzY3JvbGwuXG4gICAgICAgICAgICAgICAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXN1YWxWaWV3cG9ydC5oZWlnaHQgPCB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXlib2FyZCBpcyBhbHJlYWR5IHZpc2libGUsIGRvIHRoaXMgYWZ0ZXIgb25lIGFkZGl0aW9uYWwgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHdhaXQgZm9yIHRoZSB0cmFuc2Zvcm0gdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2FpdCBmb3IgdGhlIHZpc3VhbCB2aWV3cG9ydCB0byByZXNpemUgYmVmb3JlIHNjcm9sbGluZyBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYXN1cmUgdGhlIGNvcnJlY3QgcG9zaXRpb24gdG8gc2Nyb2xsIHRvLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk9PnNjcm9sbEludG9WaWV3KHRhcmdldCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgb25XaW5kb3dTY3JvbGwgPSAoKT0+e1xuICAgICAgICAvLyBMYXN0IHJlc29ydC4gSWYgdGhlIHdpbmRvdyBzY3JvbGxlZCwgc2Nyb2xsIGl0IGJhY2sgdG8gdGhlIHRvcC5cbiAgICAgICAgLy8gSXQgc2hvdWxkIGFsd2F5cyBiZSBhdCB0aGUgdG9wIGJlY2F1c2UgdGhlIGJvZHkgd2lsbCBoYXZlIGEgbmVnYXRpdmUgbWFyZ2luIChzZWUgYmVsb3cpLlxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfTtcbiAgICAvLyBSZWNvcmQgdGhlIG9yaWdpbmFsIHNjcm9sbCBwb3NpdGlvbiBzbyB3ZSBjYW4gcmVzdG9yZSBpdC5cbiAgICAvLyBUaGVuIGFwcGx5IGEgbmVnYXRpdmUgbWFyZ2luIHRvIHRoZSBib2R5IHRvIG9mZnNldCBpdCBieSB0aGUgc2Nyb2xsIHBvc2l0aW9uLiBUaGlzIHdpbGxcbiAgICAvLyBlbmFibGUgdXMgdG8gc2Nyb2xsIHRoZSB3aW5kb3cgdG8gdGhlIHRvcCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHRoZSByZXN0IG9mIHRoaXMgdG8gd29yay5cbiAgICBsZXQgc2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBsZXQgc2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBsZXQgcmVzdG9yZVN0eWxlcyA9IGNoYWluKHNldFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ3BhZGRpbmdSaWdodCcsIGAke3dpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofXB4YCkpO1xuICAgIC8vIFNjcm9sbCB0byB0aGUgdG9wLiBUaGUgbmVnYXRpdmUgbWFyZ2luIG9uIHRoZSBib2R5IHdpbGwgbWFrZSB0aGlzIGFwcGVhciB0aGUgc2FtZS5cbiAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgbGV0IHJlbW92ZUV2ZW50cyA9IGNoYWluKGFkZEV2ZW50KGRvY3VtZW50LCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLCBhZGRFdmVudChkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSksIGFkZEV2ZW50KGRvY3VtZW50LCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSksIGFkZEV2ZW50KGRvY3VtZW50LCAnZm9jdXMnLCBvbkZvY3VzLCB0cnVlKSwgYWRkRXZlbnQod2luZG93LCAnc2Nyb2xsJywgb25XaW5kb3dTY3JvbGwpKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgLy8gUmVzdG9yZSBzdHlsZXMgYW5kIHNjcm9sbCB0aGUgcGFnZSBiYWNrIHRvIHdoZXJlIGl0IHdhcy5cbiAgICAgICAgcmVzdG9yZVN0eWxlcygpO1xuICAgICAgICByZW1vdmVFdmVudHMoKTtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFgsIHNjcm9sbFkpO1xuICAgIH07XG59XG4vLyBTZXRzIGEgQ1NTIHByb3BlcnR5IG9uIGFuIGVsZW1lbnQsIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gcmV2ZXJ0IGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZS5cbmZ1bmN0aW9uIHNldFN0eWxlKGVsZW1lbnQsIHN0eWxlLCB2YWx1ZSkge1xuICAgIGxldCBjdXIgPSBlbGVtZW50LnN0eWxlW3N0eWxlXTtcbiAgICBlbGVtZW50LnN0eWxlW3N0eWxlXSA9IHZhbHVlO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlXSA9IGN1cjtcbiAgICB9O1xufVxuLy8gQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBlbGVtZW50LCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHJlbW92ZSBpdC5cbmZ1bmN0aW9uIGFkZEV2ZW50KHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgbGV0IHJvb3QgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB3aGlsZSh0YXJnZXQgJiYgdGFyZ2V0ICE9PSByb290KXtcbiAgICAgICAgLy8gRmluZCB0aGUgcGFyZW50IHNjcm9sbGFibGUgZWxlbWVudCBhbmQgYWRqdXN0IHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgdGhlIHRhcmdldCBpcyBub3QgYWxyZWFkeSBpbiB2aWV3LlxuICAgICAgICBsZXQgc2Nyb2xsYWJsZSA9IGdldFNjcm9sbFBhcmVudCh0YXJnZXQpO1xuICAgICAgICBpZiAoc2Nyb2xsYWJsZSAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHNjcm9sbGFibGUgIT09IGRvY3VtZW50LmJvZHkgJiYgc2Nyb2xsYWJsZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsYWJsZVRvcCA9IHNjcm9sbGFibGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgICAgbGV0IHRhcmdldFRvcCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGtleWJvYXJkSGVpZ2h0ID0gc2Nyb2xsYWJsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b207XG4gICAgICAgICAgICBpZiAodGFyZ2V0Qm90dG9tID4ga2V5Ym9hcmRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLnNjcm9sbFRvcCArPSB0YXJnZXRUb3AgLSBzY3JvbGxhYmxlVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGFyZ2V0ID0gc2Nyb2xsYWJsZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSW5wdXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgIW5vblRleHRJbnB1dFR5cGVzLmhhcyh0YXJnZXQudHlwZSkgfHwgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQuaXNDb250ZW50RWRpdGFibGU7XG59XG5cbi8vIFRoaXMgY29kZSBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWRpeC11aS9wcmltaXRpdmVzL3RyZWUvbWFpbi9wYWNrYWdlcy9yZWFjdC9jb21wb3NlLXJlZnNcbi8qKlxuICogU2V0IGEgZ2l2ZW4gcmVmIHRvIGEgZ2l2ZW4gdmFsdWVcbiAqIFRoaXMgdXRpbGl0eSB0YWtlcyBjYXJlIG9mIGRpZmZlcmVudCB0eXBlcyBvZiByZWZzOiBjYWxsYmFjayByZWZzIGFuZCBSZWZPYmplY3QocylcbiAqLyBmdW5jdGlvbiBzZXRSZWYocmVmLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlZih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChyZWYgIT09IG51bGwgJiYgcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIEEgdXRpbGl0eSB0byBjb21wb3NlIG11bHRpcGxlIHJlZnMgdG9nZXRoZXJcbiAqIEFjY2VwdHMgY2FsbGJhY2sgcmVmcyBhbmQgUmVmT2JqZWN0KHMpXG4gKi8gZnVuY3Rpb24gY29tcG9zZVJlZnMoLi4ucmVmcykge1xuICAgIHJldHVybiAobm9kZSk9PnJlZnMuZm9yRWFjaCgocmVmKT0+c2V0UmVmKHJlZiwgbm9kZSkpO1xufVxuLyoqXG4gKiBBIGN1c3RvbSBob29rIHRoYXQgY29tcG9zZXMgbXVsdGlwbGUgcmVmc1xuICogQWNjZXB0cyBjYWxsYmFjayByZWZzIGFuZCBSZWZPYmplY3QocylcbiAqLyBmdW5jdGlvbiB1c2VDb21wb3NlZFJlZnMoLi4ucmVmcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soY29tcG9zZVJlZnMoLi4ucmVmcyksIHJlZnMpO1xufVxuXG5sZXQgcHJldmlvdXNCb2R5UG9zaXRpb24gPSBudWxsO1xuZnVuY3Rpb24gdXNlUG9zaXRpb25GaXhlZCh7IGlzT3BlbiwgbW9kYWwsIG5lc3RlZCwgaGFzQmVlbk9wZW5lZCwgcHJldmVudFNjcm9sbFJlc3RvcmF0aW9uLCBub0JvZHlTdHlsZXMgfSkge1xuICAgIGNvbnN0IFthY3RpdmVVcmwsIHNldEFjdGl2ZVVybF0gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZSgoKT0+dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICcnKTtcbiAgICBjb25zdCBzY3JvbGxQb3MgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoMCk7XG4gICAgY29uc3Qgc2V0UG9zaXRpb25GaXhlZCA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIC8vIElmIHByZXZpb3VzQm9keVBvc2l0aW9uIGlzIGFscmVhZHkgc2V0LCBkb24ndCBzZXQgaXQgYWdhaW4uXG4gICAgICAgIGlmIChwcmV2aW91c0JvZHlQb3NpdGlvbiA9PT0gbnVsbCAmJiBpc09wZW4gJiYgIW5vQm9keVN0eWxlcykge1xuICAgICAgICAgICAgcHJldmlvdXNCb2R5UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRvY3VtZW50LmJvZHkuc3R5bGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9wOiBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBkb2N1bWVudC5ib2R5LnN0eWxlLmxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCxcbiAgICAgICAgICAgICAgICByaWdodDogJ3Vuc2V0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZG9tIGluc2lkZSBhbiBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsWCwgaW5uZXJIZWlnaHQgfSA9IHdpbmRvdztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJ3Bvc2l0aW9uJywgJ2ZpeGVkJywgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkb2N1bWVudC5ib2R5LnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdG9wOiBgJHstc2Nyb2xsUG9zLmN1cnJlbnR9cHhgLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGAkey1zY3JvbGxYfXB4YCxcbiAgICAgICAgICAgICAgICByaWdodDogJzBweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnYXV0bydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCk9PndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBjaGVjayBpZiB0aGUgYm90dG9tIGJhciBhcHBlYXJlZCBkdWUgdG8gdGhlIHBvc2l0aW9uIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3R0b21CYXJIZWlnaHQgPSBpbm5lckhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbUJhckhlaWdodCAmJiBzY3JvbGxQb3MuY3VycmVudCA+PSBpbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgY29udGVudCBmdXJ0aGVyIHVwIHNvIHRoYXQgdGhlIGJvdHRvbSBiYXIgZG9lc24ndCBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9IGAkey0oc2Nyb2xsUG9zLmN1cnJlbnQgKyBib3R0b21CYXJIZWlnaHQpfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCAzMDApO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc09wZW5cbiAgICBdKTtcbiAgICBjb25zdCByZXN0b3JlUG9zaXRpb25TZXR0aW5nID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgaWYgKHByZXZpb3VzQm9keVBvc2l0aW9uICE9PSBudWxsICYmICFub0JvZHlTdHlsZXMpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHBvc2l0aW9uIGZyb20gXCJweFwiIHRvIEludFxuICAgICAgICAgICAgY29uc3QgeSA9IC1wYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCwgMTApO1xuICAgICAgICAgICAgY29uc3QgeCA9IC1wYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLmxlZnQsIDEwKTtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgc3R5bGVzXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRvY3VtZW50LmJvZHkuc3R5bGUsIHByZXZpb3VzQm9keVBvc2l0aW9uKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudFNjcm9sbFJlc3RvcmF0aW9uICYmIGFjdGl2ZVVybCAhPT0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlVXJsKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oeCwgeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByZXZpb3VzQm9keVBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYWN0aXZlVXJsXG4gICAgXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGZ1bmN0aW9uIG9uU2Nyb2xsKCkge1xuICAgICAgICAgICAgc2Nyb2xsUG9zLmN1cnJlbnQgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgfVxuICAgICAgICBvblNjcm9sbCgpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAobmVzdGVkIHx8ICFoYXNCZWVuT3BlbmVkKSByZXR1cm47XG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGZvcmNlIFNhZmFyaSB0b29sYmFyIHRvIHNob3cgKipiZWZvcmUqKiB0aGUgZHJhd2VyIHN0YXJ0cyBhbmltYXRpbmcgdG8gcHJldmVudCBhIGduYXJseSBzaGlmdCBmcm9tIGhhcHBlbmluZ1xuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBmb3Igc3RhbmRhbG9uZSBtb2RlIChQV0EpXG4gICAgICAgICAgICBjb25zdCBpc1N0YW5kYWxvbmUgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKGRpc3BsYXktbW9kZTogc3RhbmRhbG9uZSknKS5tYXRjaGVzO1xuICAgICAgICAgICAgIWlzU3RhbmRhbG9uZSAmJiBzZXRQb3NpdGlvbkZpeGVkKCk7XG4gICAgICAgICAgICBpZiAoIW1vZGFsKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZVBvc2l0aW9uU2V0dGluZygpO1xuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN0b3JlUG9zaXRpb25TZXR0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgaGFzQmVlbk9wZW5lZCxcbiAgICAgICAgYWN0aXZlVXJsLFxuICAgICAgICBtb2RhbCxcbiAgICAgICAgbmVzdGVkLFxuICAgICAgICBzZXRQb3NpdGlvbkZpeGVkLFxuICAgICAgICByZXN0b3JlUG9zaXRpb25TZXR0aW5nXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdG9yZVBvc2l0aW9uU2V0dGluZ1xuICAgIH07XG59XG5cbmNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldChlbCwgc3R5bGVzLCBpZ25vcmVDYWNoZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFlbCB8fCAhKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm47XG4gICAgbGV0IG9yaWdpbmFsU3R5bGVzID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMoc3R5bGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pPT57XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgICAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ2luYWxTdHlsZXNba2V5XSA9IGVsLnN0eWxlW2tleV07XG4gICAgICAgIGVsLnN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBpZiAoaWdub3JlQ2FjaGUpIHJldHVybjtcbiAgICBjYWNoZS5zZXQoZWwsIG9yaWdpbmFsU3R5bGVzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0KGVsLCBwcm9wKSB7XG4gICAgaWYgKCFlbCB8fCAhKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm47XG4gICAgbGV0IG9yaWdpbmFsU3R5bGVzID0gY2FjaGUuZ2V0KGVsKTtcbiAgICBpZiAoIW9yaWdpbmFsU3R5bGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3ApIHtcbiAgICAgICAgZWwuc3R5bGVbcHJvcF0gPSBvcmlnaW5hbFN0eWxlc1twcm9wXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuZW50cmllcyhvcmlnaW5hbFN0eWxlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKT0+e1xuICAgICAgICAgICAgZWwuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBpc1ZlcnRpY2FsID0gKGRpcmVjdGlvbik9PntcbiAgICBzd2l0Y2goZGlyZWN0aW9uKXtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlKGVsZW1lbnQsIGRpcmVjdGlvbikge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSAvLyBAdHMtaWdub3JlXG4gICAgc3R5bGUudHJhbnNmb3JtIHx8IHN0eWxlLndlYmtpdFRyYW5zZm9ybSB8fCBzdHlsZS5tb3pUcmFuc2Zvcm07XG4gICAgbGV0IG1hdCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeDNkXFwoKC4rKVxcKSQvKTtcbiAgICBpZiAobWF0KSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90cmFuc2Zvcm0tZnVuY3Rpb24vbWF0cml4M2RcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0WzFdLnNwbGl0KCcsICcpW2lzVmVydGljYWwoZGlyZWN0aW9uKSA/IDEzIDogMTJdKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1mdW5jdGlvbi9tYXRyaXhcbiAgICBtYXQgPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC8pO1xuICAgIHJldHVybiBtYXQgPyBwYXJzZUZsb2F0KG1hdFsxXS5zcGxpdCgnLCAnKVtpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyA1IDogNF0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGRhbXBlblZhbHVlKHYpIHtcbiAgICByZXR1cm4gOCAqIChNYXRoLmxvZyh2ICsgMSkgLSAyKTtcbn1cblxuY29uc3QgVFJBTlNJVElPTlMgPSB7XG4gICAgRFVSQVRJT046IDAuNSxcbiAgICBFQVNFOiBbXG4gICAgICAgIDAuMzIsXG4gICAgICAgIDAuNzIsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICBdXG59O1xuY29uc3QgVkVMT0NJVFlfVEhSRVNIT0xEID0gMC40O1xuXG4vLyBUaGlzIGNvZGUgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcmFkaXgtdWkvcHJpbWl0aXZlcy9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QvdXNlLWNvbnRyb2xsYWJsZS1zdGF0ZS9zcmMvdXNlQ29udHJvbGxhYmxlU3RhdGUudHN4XG5mdW5jdGlvbiB1c2VDYWxsYmFja1JlZihjYWxsYmFjaykge1xuICAgIGNvbnN0IGNhbGxiYWNrUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGNhbGxiYWNrKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICAgIH0pO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkyNDBcbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKT0+KC4uLmFyZ3MpPT5jYWxsYmFja1JlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja1JlZi5jdXJyZW50LmNhbGwoY2FsbGJhY2tSZWYsIC4uLmFyZ3MpLCBbXSk7XG59XG5mdW5jdGlvbiB1c2VVbmNvbnRyb2xsZWRTdGF0ZSh7IGRlZmF1bHRQcm9wLCBvbkNoYW5nZSB9KSB7XG4gICAgY29uc3QgdW5jb250cm9sbGVkU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShkZWZhdWx0UHJvcCk7XG4gICAgY29uc3QgW3ZhbHVlXSA9IHVuY29udHJvbGxlZFN0YXRlO1xuICAgIGNvbnN0IHByZXZWYWx1ZVJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZih2YWx1ZSk7XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2tSZWYob25DaGFuZ2UpO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAocHJldlZhbHVlUmVmLmN1cnJlbnQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBoYW5kbGVDaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgcHJldlZhbHVlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHByZXZWYWx1ZVJlZixcbiAgICAgICAgaGFuZGxlQ2hhbmdlXG4gICAgXSk7XG4gICAgcmV0dXJuIHVuY29udHJvbGxlZFN0YXRlO1xufVxuZnVuY3Rpb24gdXNlQ29udHJvbGxhYmxlU3RhdGUoeyBwcm9wLCBkZWZhdWx0UHJvcCwgb25DaGFuZ2UgPSAoKT0+e30gfSkge1xuICAgIGNvbnN0IFt1bmNvbnRyb2xsZWRQcm9wLCBzZXRVbmNvbnRyb2xsZWRQcm9wXSA9IHVzZVVuY29udHJvbGxlZFN0YXRlKHtcbiAgICAgICAgZGVmYXVsdFByb3AsXG4gICAgICAgIG9uQ2hhbmdlXG4gICAgfSk7XG4gICAgY29uc3QgaXNDb250cm9sbGVkID0gcHJvcCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHZhbHVlID0gaXNDb250cm9sbGVkID8gcHJvcCA6IHVuY29udHJvbGxlZFByb3A7XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2tSZWYob25DaGFuZ2UpO1xuICAgIGNvbnN0IHNldFZhbHVlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soKG5leHRWYWx1ZSk9PntcbiAgICAgICAgaWYgKGlzQ29udHJvbGxlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGVyID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgbmV4dFZhbHVlID09PSAnZnVuY3Rpb24nID8gc2V0dGVyKHByb3ApIDogbmV4dFZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBwcm9wKSBoYW5kbGVDaGFuZ2UodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VW5jb250cm9sbGVkUHJvcChuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0NvbnRyb2xsZWQsXG4gICAgICAgIHByb3AsXG4gICAgICAgIHNldFVuY29udHJvbGxlZFByb3AsXG4gICAgICAgIGhhbmRsZUNoYW5nZVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBzZXRWYWx1ZVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZVNuYXBQb2ludHMoeyBhY3RpdmVTbmFwUG9pbnRQcm9wLCBzZXRBY3RpdmVTbmFwUG9pbnRQcm9wLCBzbmFwUG9pbnRzLCBkcmF3ZXJSZWYsIG92ZXJsYXlSZWYsIGZhZGVGcm9tSW5kZXgsIG9uU25hcFBvaW50Q2hhbmdlLCBkaXJlY3Rpb24gPSAnYm90dG9tJyB9KSB7XG4gICAgY29uc3QgW2FjdGl2ZVNuYXBQb2ludCwgc2V0QWN0aXZlU25hcFBvaW50XSA9IHVzZUNvbnRyb2xsYWJsZVN0YXRlKHtcbiAgICAgICAgcHJvcDogYWN0aXZlU25hcFBvaW50UHJvcCxcbiAgICAgICAgZGVmYXVsdFByb3A6IHNuYXBQb2ludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHNbMF0sXG4gICAgICAgIG9uQ2hhbmdlOiBzZXRBY3RpdmVTbmFwUG9pbnRQcm9wXG4gICAgfSk7XG4gICAgY29uc3QgaXNMYXN0U25hcFBvaW50ID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKT0+YWN0aXZlU25hcFBvaW50ID09PSAoc25hcFBvaW50cyA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c1tzbmFwUG9pbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsLCBbXG4gICAgICAgIHNuYXBQb2ludHMsXG4gICAgICAgIGFjdGl2ZVNuYXBQb2ludFxuICAgIF0pO1xuICAgIGNvbnN0IHNob3VsZEZhZGUgPSBzbmFwUG9pbnRzICYmIHNuYXBQb2ludHMubGVuZ3RoID4gMCAmJiAoZmFkZUZyb21JbmRleCB8fCBmYWRlRnJvbUluZGV4ID09PSAwKSAmJiAhTnVtYmVyLmlzTmFOKGZhZGVGcm9tSW5kZXgpICYmIHNuYXBQb2ludHNbZmFkZUZyb21JbmRleF0gPT09IGFjdGl2ZVNuYXBQb2ludCB8fCAhc25hcFBvaW50cztcbiAgICBjb25zdCBhY3RpdmVTbmFwUG9pbnRJbmRleCA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCk9PnNuYXBQb2ludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHMuZmluZEluZGV4KChzbmFwUG9pbnQpPT5zbmFwUG9pbnQgPT09IGFjdGl2ZVNuYXBQb2ludCksIFtcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50XG4gICAgXSk7XG4gICAgY29uc3Qgc25hcFBvaW50c09mZnNldCA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgdmFyIF9zbmFwUG9pbnRzX21hcDtcbiAgICAgICAgcmV0dXJuIChfc25hcFBvaW50c19tYXAgPSBzbmFwUG9pbnRzID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzLm1hcCgoc25hcFBvaW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaGFzV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBjb25zdCBpc1B4ID0gdHlwZW9mIHNuYXBQb2ludCA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICBsZXQgc25hcFBvaW50QXNOdW1iZXIgPSAwO1xuICAgICAgICAgICAgaWYgKGlzUHgpIHtcbiAgICAgICAgICAgICAgICBzbmFwUG9pbnRBc051bWJlciA9IHBhcnNlSW50KHNuYXBQb2ludCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmVydGljYWwoZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGlzUHggPyBzbmFwUG9pbnRBc051bWJlciA6IGhhc1dpbmRvdyA/IHNuYXBQb2ludCAqIHdpbmRvdy5pbm5lckhlaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1dpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHdpbmRvdy5pbm5lckhlaWdodCAtIGhlaWdodCA6IC13aW5kb3cuaW5uZXJIZWlnaHQgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGlzUHggPyBzbmFwUG9pbnRBc051bWJlciA6IGhhc1dpbmRvdyA/IHNuYXBQb2ludCAqIHdpbmRvdy5pbm5lcldpZHRoIDogMDtcbiAgICAgICAgICAgIGlmIChoYXNXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncmlnaHQnID8gd2luZG93LmlubmVyV2lkdGggLSB3aWR0aCA6IC13aW5kb3cuaW5uZXJXaWR0aCArIHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9KSkgIT0gbnVsbCA/IF9zbmFwUG9pbnRzX21hcCA6IFtdO1xuICAgIH0sIFtcbiAgICAgICAgc25hcFBvaW50c1xuICAgIF0pO1xuICAgIGNvbnN0IGFjdGl2ZVNuYXBQb2ludE9mZnNldCA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCk9PmFjdGl2ZVNuYXBQb2ludEluZGV4ICE9PSBudWxsID8gc25hcFBvaW50c09mZnNldCA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c09mZnNldFthY3RpdmVTbmFwUG9pbnRJbmRleF0gOiBudWxsLCBbXG4gICAgICAgIHNuYXBQb2ludHNPZmZzZXQsXG4gICAgICAgIGFjdGl2ZVNuYXBQb2ludEluZGV4XG4gICAgXSk7XG4gICAgY29uc3Qgc25hcFRvUG9pbnQgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygoZGltZW5zaW9uKT0+e1xuICAgICAgICB2YXIgX3NuYXBQb2ludHNPZmZzZXRfZmluZEluZGV4O1xuICAgICAgICBjb25zdCBuZXdTbmFwUG9pbnRJbmRleCA9IChfc25hcFBvaW50c09mZnNldF9maW5kSW5kZXggPSBzbmFwUG9pbnRzT2Zmc2V0ID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzT2Zmc2V0LmZpbmRJbmRleCgoc25hcFBvaW50RGltKT0+c25hcFBvaW50RGltID09PSBkaW1lbnNpb24pKSAhPSBudWxsID8gX3NuYXBQb2ludHNPZmZzZXRfZmluZEluZGV4IDogbnVsbDtcbiAgICAgICAgb25TbmFwUG9pbnRDaGFuZ2UobmV3U25hcFBvaW50SW5kZXgpO1xuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGB0cmFuc2Zvcm0gJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgdHJhbnNsYXRlM2QoMCwgJHtkaW1lbnNpb259cHgsIDApYCA6IGB0cmFuc2xhdGUzZCgke2RpbWVuc2lvbn1weCwgMCwgMClgXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc25hcFBvaW50c09mZnNldCAmJiBuZXdTbmFwUG9pbnRJbmRleCAhPT0gc25hcFBvaW50c09mZnNldC5sZW5ndGggLSAxICYmIG5ld1NuYXBQb2ludEluZGV4ICE9PSBmYWRlRnJvbUluZGV4KSB7XG4gICAgICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcxJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50KG5ld1NuYXBQb2ludEluZGV4ICE9PSBudWxsID8gc25hcFBvaW50cyA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c1tuZXdTbmFwUG9pbnRJbmRleF0gOiBudWxsKTtcbiAgICB9LCBbXG4gICAgICAgIGRyYXdlclJlZi5jdXJyZW50LFxuICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICBzbmFwUG9pbnRzT2Zmc2V0LFxuICAgICAgICBmYWRlRnJvbUluZGV4LFxuICAgICAgICBvdmVybGF5UmVmLFxuICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnRcbiAgICBdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGFjdGl2ZVNuYXBQb2ludCB8fCBhY3RpdmVTbmFwUG9pbnRQcm9wKSB7XG4gICAgICAgICAgICB2YXIgX3NuYXBQb2ludHNfZmluZEluZGV4O1xuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSAoX3NuYXBQb2ludHNfZmluZEluZGV4ID0gc25hcFBvaW50cyA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50cy5maW5kSW5kZXgoKHNuYXBQb2ludCk9PnNuYXBQb2ludCA9PT0gYWN0aXZlU25hcFBvaW50UHJvcCB8fCBzbmFwUG9pbnQgPT09IGFjdGl2ZVNuYXBQb2ludCkpICE9IG51bGwgPyBfc25hcFBvaW50c19maW5kSW5kZXggOiAtMTtcbiAgICAgICAgICAgIGlmIChzbmFwUG9pbnRzT2Zmc2V0ICYmIG5ld0luZGV4ICE9PSAtMSAmJiB0eXBlb2Ygc25hcFBvaW50c09mZnNldFtuZXdJbmRleF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc25hcFRvUG9pbnQoc25hcFBvaW50c09mZnNldFtuZXdJbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVTbmFwUG9pbnQsXG4gICAgICAgIGFjdGl2ZVNuYXBQb2ludFByb3AsXG4gICAgICAgIHNuYXBQb2ludHMsXG4gICAgICAgIHNuYXBQb2ludHNPZmZzZXQsXG4gICAgICAgIHNuYXBUb1BvaW50XG4gICAgXSk7XG4gICAgZnVuY3Rpb24gb25SZWxlYXNlKHsgZHJhZ2dlZERpc3RhbmNlLCBjbG9zZURyYXdlciwgdmVsb2NpdHksIGRpc21pc3NpYmxlIH0pIHtcbiAgICAgICAgaWYgKGZhZGVGcm9tSW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSBkaXJlY3Rpb24gPT09ICdib3R0b20nIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IChhY3RpdmVTbmFwUG9pbnRPZmZzZXQgIT0gbnVsbCA/IGFjdGl2ZVNuYXBQb2ludE9mZnNldCA6IDApIC0gZHJhZ2dlZERpc3RhbmNlIDogKGFjdGl2ZVNuYXBQb2ludE9mZnNldCAhPSBudWxsID8gYWN0aXZlU25hcFBvaW50T2Zmc2V0IDogMCkgKyBkcmFnZ2VkRGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IGlzT3ZlcmxheVNuYXBQb2ludCA9IGFjdGl2ZVNuYXBQb2ludEluZGV4ID09PSBmYWRlRnJvbUluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgaXNGaXJzdCA9IGFjdGl2ZVNuYXBQb2ludEluZGV4ID09PSAwO1xuICAgICAgICBjb25zdCBoYXNEcmFnZ2VkVXAgPSBkcmFnZ2VkRGlzdGFuY2UgPiAwO1xuICAgICAgICBpZiAoaXNPdmVybGF5U25hcFBvaW50KSB7XG4gICAgICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVsb2NpdHkgPiAyICYmICFoYXNEcmFnZ2VkVXApIHtcbiAgICAgICAgICAgIGlmIChkaXNtaXNzaWJsZSkgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIGVsc2Ugc25hcFRvUG9pbnQoc25hcFBvaW50c09mZnNldFswXSk7IC8vIHNuYXAgdG8gaW5pdGlhbCBwb2ludFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IDIgJiYgaGFzRHJhZ2dlZFVwICYmIHNuYXBQb2ludHNPZmZzZXQgJiYgc25hcFBvaW50cykge1xuICAgICAgICAgICAgc25hcFRvUG9pbnQoc25hcFBvaW50c09mZnNldFtzbmFwUG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHNuYXAgcG9pbnQgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgY2xvc2VzdFNuYXBQb2ludCA9IHNuYXBQb2ludHNPZmZzZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHNPZmZzZXQucmVkdWNlKChwcmV2LCBjdXJyKT0+e1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY3VyciAhPT0gJ251bWJlcicpIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGN1cnIgLSBjdXJyZW50UG9zaXRpb24pIDwgTWF0aC5hYnMocHJldiAtIGN1cnJlbnRQb3NpdGlvbikgPyBjdXJyIDogcHJldjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRpbSA9IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBpZiAodmVsb2NpdHkgPiBWRUxPQ0lUWV9USFJFU0hPTEQgJiYgTWF0aC5hYnMoZHJhZ2dlZERpc3RhbmNlKSA8IGRpbSAqIDAuNCkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0RpcmVjdGlvbiA9IGhhc0RyYWdnZWRVcCA/IDEgOiAtMTsgLy8gMSA9IHVwLCAtMSA9IGRvd25cbiAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXBlIHVwd2FyZHMgd2hpbGUgYmVpbmcgb24gdGhlIGxhc3Qgc25hcCBwb2ludFxuICAgICAgICAgICAgaWYgKGRyYWdEaXJlY3Rpb24gPiAwICYmIGlzTGFzdFNuYXBQb2ludCkge1xuICAgICAgICAgICAgICAgIHNuYXBUb1BvaW50KHNuYXBQb2ludHNPZmZzZXRbc25hcFBvaW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmlyc3QgJiYgZHJhZ0RpcmVjdGlvbiA8IDAgJiYgZGlzbWlzc2libGUpIHtcbiAgICAgICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGl2ZVNuYXBQb2ludEluZGV4ID09PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICBzbmFwVG9Qb2ludChzbmFwUG9pbnRzT2Zmc2V0W2FjdGl2ZVNuYXBQb2ludEluZGV4ICsgZHJhZ0RpcmVjdGlvbl0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNuYXBUb1BvaW50KGNsb3Nlc3RTbmFwUG9pbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkRyYWcoeyBkcmFnZ2VkRGlzdGFuY2UgfSkge1xuICAgICAgICBpZiAoYWN0aXZlU25hcFBvaW50T2Zmc2V0ID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZGlyZWN0aW9uID09PSAnYm90dG9tJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBhY3RpdmVTbmFwUG9pbnRPZmZzZXQgLSBkcmFnZ2VkRGlzdGFuY2UgOiBhY3RpdmVTbmFwUG9pbnRPZmZzZXQgKyBkcmFnZ2VkRGlzdGFuY2U7XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHdlIGV4Y2VlZCB0aGUgbGFzdChiaWdnZXN0KSBzbmFwIHBvaW50XG4gICAgICAgIGlmICgoZGlyZWN0aW9uID09PSAnYm90dG9tJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcpICYmIG5ld1ZhbHVlIDwgc25hcFBvaW50c09mZnNldFtzbmFwUG9pbnRzT2Zmc2V0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChkaXJlY3Rpb24gPT09ICd0b3AnIHx8IGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSAmJiBuZXdWYWx1ZSA+IHNuYXBQb2ludHNPZmZzZXRbc25hcFBvaW50c09mZnNldC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgdHJhbnNsYXRlM2QoMCwgJHtuZXdWYWx1ZX1weCwgMClgIDogYHRyYW5zbGF0ZTNkKCR7bmV3VmFsdWV9cHgsIDAsIDApYFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGVyY2VudGFnZURyYWdnZWQoYWJzRHJhZ2dlZERpc3RhbmNlLCBpc0RyYWdnaW5nRG93bikge1xuICAgICAgICBpZiAoIXNuYXBQb2ludHMgfHwgdHlwZW9mIGFjdGl2ZVNuYXBQb2ludEluZGV4ICE9PSAnbnVtYmVyJyB8fCAhc25hcFBvaW50c09mZnNldCB8fCBmYWRlRnJvbUluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRydWUgd2UgYXJlIGRyYWdnaW5nIHRvIGEgc25hcCBwb2ludCB0aGF0IGlzIHN1cHBvc2VkIHRvIGhhdmUgYW4gb3ZlcmxheVxuICAgICAgICBjb25zdCBpc092ZXJsYXlTbmFwUG9pbnQgPSBhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gZmFkZUZyb21JbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGlzT3ZlcmxheVNuYXBQb2ludE9ySGlnaGVyID0gYWN0aXZlU25hcFBvaW50SW5kZXggPj0gZmFkZUZyb21JbmRleDtcbiAgICAgICAgaWYgKGlzT3ZlcmxheVNuYXBQb2ludE9ySGlnaGVyICYmIGlzRHJhZ2dpbmdEb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCBhbmltYXRlLCBidXQgc3RpbGwgdXNlIHRoaXMgb25lIGlmIHdlIGFyZSBkcmFnZ2luZyBhd2F5IGZyb20gdGhlIG92ZXJsYXlTbmFwUG9pbnRcbiAgICAgICAgaWYgKGlzT3ZlcmxheVNuYXBQb2ludCAmJiAhaXNEcmFnZ2luZ0Rvd24pIHJldHVybiAxO1xuICAgICAgICBpZiAoIXNob3VsZEZhZGUgJiYgIWlzT3ZlcmxheVNuYXBQb2ludCkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEVpdGhlciBmYWRlRnJvbSBpbmRleCBvciB0aGUgb25lIGJlZm9yZVxuICAgICAgICBjb25zdCB0YXJnZXRTbmFwUG9pbnRJbmRleCA9IGlzT3ZlcmxheVNuYXBQb2ludCA/IGFjdGl2ZVNuYXBQb2ludEluZGV4ICsgMSA6IGFjdGl2ZVNuYXBQb2ludEluZGV4IC0gMTtcbiAgICAgICAgLy8gR2V0IHRoZSBkaXN0YW5jZSBmcm9tIG92ZXJsYXlTbmFwUG9pbnQgdG8gdGhlIG9uZSBiZWZvcmUgb3IgdmljZS12ZXJzYSB0byBjYWxjdWxhdGUgdGhlIG9wYWNpdHkgcGVyY2VudGFnZSBhY2NvcmRpbmdseVxuICAgICAgICBjb25zdCBzbmFwUG9pbnREaXN0YW5jZSA9IGlzT3ZlcmxheVNuYXBQb2ludCA/IHNuYXBQb2ludHNPZmZzZXRbdGFyZ2V0U25hcFBvaW50SW5kZXhdIC0gc25hcFBvaW50c09mZnNldFt0YXJnZXRTbmFwUG9pbnRJbmRleCAtIDFdIDogc25hcFBvaW50c09mZnNldFt0YXJnZXRTbmFwUG9pbnRJbmRleCArIDFdIC0gc25hcFBvaW50c09mZnNldFt0YXJnZXRTbmFwUG9pbnRJbmRleF07XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VEcmFnZ2VkID0gYWJzRHJhZ2dlZERpc3RhbmNlIC8gTWF0aC5hYnMoc25hcFBvaW50RGlzdGFuY2UpO1xuICAgICAgICBpZiAoaXNPdmVybGF5U25hcFBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIHBlcmNlbnRhZ2VEcmFnZ2VkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRhZ2VEcmFnZ2VkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzTGFzdFNuYXBQb2ludCxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50LFxuICAgICAgICBzaG91bGRGYWRlLFxuICAgICAgICBnZXRQZXJjZW50YWdlRHJhZ2dlZCxcbiAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50LFxuICAgICAgICBhY3RpdmVTbmFwUG9pbnRJbmRleCxcbiAgICAgICAgb25SZWxlYXNlLFxuICAgICAgICBvbkRyYWcsXG4gICAgICAgIHNuYXBQb2ludHNPZmZzZXRcbiAgICB9O1xufVxuXG5jb25zdCBDTE9TRV9USFJFU0hPTEQgPSAwLjI1O1xuY29uc3QgU0NST0xMX0xPQ0tfVElNRU9VVCA9IDEwMDtcbmNvbnN0IEJPUkRFUl9SQURJVVMgPSA4O1xuY29uc3QgTkVTVEVEX0RJU1BMQUNFTUVOVCA9IDE2O1xuY29uc3QgV0lORE9XX1RPUF9PRkZTRVQgPSAyNjtcbmNvbnN0IERSQUdfQ0xBU1MgPSAndmF1bC1kcmFnZ2luZyc7XG5mdW5jdGlvbiBSb290KHsgb3Blbjogb3BlblByb3AsIG9uT3BlbkNoYW5nZSwgY2hpbGRyZW4sIHNob3VsZFNjYWxlQmFja2dyb3VuZCwgb25EcmFnOiBvbkRyYWdQcm9wLCBvblJlbGVhc2U6IG9uUmVsZWFzZVByb3AsIHNuYXBQb2ludHMsIG5lc3RlZCA9IGZhbHNlLCBzZXRCYWNrZ3JvdW5kQ29sb3JPblNjYWxlID0gdHJ1ZSwgY2xvc2VUaHJlc2hvbGQgPSBDTE9TRV9USFJFU0hPTEQsIHNjcm9sbExvY2tUaW1lb3V0ID0gU0NST0xMX0xPQ0tfVElNRU9VVCwgZGlzbWlzc2libGUgPSB0cnVlLCBoYW5kbGVPbmx5ID0gZmFsc2UsIGZhZGVGcm9tSW5kZXggPSBzbmFwUG9pbnRzICYmIHNuYXBQb2ludHMubGVuZ3RoIC0gMSwgYWN0aXZlU25hcFBvaW50OiBhY3RpdmVTbmFwUG9pbnRQcm9wLCBzZXRBY3RpdmVTbmFwUG9pbnQ6IHNldEFjdGl2ZVNuYXBQb2ludFByb3AsIGZpeGVkLCBtb2RhbCA9IHRydWUsIG9uQ2xvc2UsIG5vQm9keVN0eWxlcywgZGlyZWN0aW9uID0gJ2JvdHRvbScsIHByZXZlbnRTY3JvbGxSZXN0b3JhdGlvbiA9IHRydWUsIGRpc2FibGVQcmV2ZW50U2Nyb2xsID0gZmFsc2UgfSkge1xuICAgIHZhciBfZHJhd2VyUmVmX2N1cnJlbnQ7XG4gICAgY29uc3QgW2lzT3BlbiA9IGZhbHNlLCBzZXRJc09wZW5dID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtoYXNCZWVuT3BlbmVkLCBzZXRIYXNCZWVuT3BlbmVkXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyBOb3QgdmlzaWJsZSA9IHRyYW5zbGF0ZVkoMTAwJSlcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5nLCBzZXRJc0RyYWdnaW5nXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbanVzdFJlbGVhc2VkLCBzZXRKdXN0UmVsZWFzZWRdID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IG92ZXJsYXlSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgb3BlblRpbWUgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZHJhZ1N0YXJ0VGltZSA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBkcmFnRW5kVGltZSA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBsYXN0VGltZURyYWdQcmV2ZW50ZWQgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaXNBbGxvd2VkVG9EcmFnID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBuZXN0ZWRPcGVuQ2hhbmdlVGltZXIgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcG9pbnRlclN0YXJ0ID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKDApO1xuICAgIGNvbnN0IGtleWJvYXJkSXNPcGVuID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBwcmV2aW91c0RpZmZGcm9tSW5pdGlhbCA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZigwKTtcbiAgICBjb25zdCBkcmF3ZXJSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZHJhd2VySGVpZ2h0UmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCgoX2RyYXdlclJlZl9jdXJyZW50ID0gZHJhd2VyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhd2VyUmVmX2N1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KSB8fCAwKTtcbiAgICBjb25zdCBpbml0aWFsRHJhd2VySGVpZ2h0ID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKDApO1xuICAgIGNvbnN0IG9uU25hcFBvaW50Q2hhbmdlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soKGFjdGl2ZVNuYXBQb2ludEluZGV4KT0+e1xuICAgICAgICAvLyBDaGFuZ2Ugb3BlblRpbWUgcmVmIHdoZW4gd2UgcmVhY2ggdGhlIGxhc3Qgc25hcCBwb2ludCB0byBwcmV2ZW50IGRyYWdnaW5nIGZvciA1MDBtcyBpbmNhc2UgaXQncyBzY3JvbGxhYmxlLlxuICAgICAgICBpZiAoc25hcFBvaW50cyAmJiBhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gc25hcFBvaW50c09mZnNldC5sZW5ndGggLSAxKSBvcGVuVGltZS5jdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgeyBhY3RpdmVTbmFwUG9pbnQsIGFjdGl2ZVNuYXBQb2ludEluZGV4LCBzZXRBY3RpdmVTbmFwUG9pbnQsIG9uUmVsZWFzZTogb25SZWxlYXNlU25hcFBvaW50cywgc25hcFBvaW50c09mZnNldCwgb25EcmFnOiBvbkRyYWdTbmFwUG9pbnRzLCBzaG91bGRGYWRlLCBnZXRQZXJjZW50YWdlRHJhZ2dlZDogZ2V0U25hcFBvaW50c1BlcmNlbnRhZ2VEcmFnZ2VkIH0gPSB1c2VTbmFwUG9pbnRzKHtcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50UHJvcCxcbiAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50UHJvcCxcbiAgICAgICAgZHJhd2VyUmVmLFxuICAgICAgICBmYWRlRnJvbUluZGV4LFxuICAgICAgICBvdmVybGF5UmVmLFxuICAgICAgICBvblNuYXBQb2ludENoYW5nZSxcbiAgICAgICAgZGlyZWN0aW9uXG4gICAgfSk7XG4gICAgdXNlUHJldmVudFNjcm9sbCh7XG4gICAgICAgIGlzRGlzYWJsZWQ6ICFpc09wZW4gfHwgaXNEcmFnZ2luZyB8fCAhbW9kYWwgfHwganVzdFJlbGVhc2VkIHx8ICFoYXNCZWVuT3BlbmVkIHx8IGRpc2FibGVQcmV2ZW50U2Nyb2xsXG4gICAgfSk7XG4gICAgY29uc3QgeyByZXN0b3JlUG9zaXRpb25TZXR0aW5nIH0gPSB1c2VQb3NpdGlvbkZpeGVkKHtcbiAgICAgICAgaXNPcGVuLFxuICAgICAgICBtb2RhbCxcbiAgICAgICAgbmVzdGVkLFxuICAgICAgICBoYXNCZWVuT3BlbmVkLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgICAgIG5vQm9keVN0eWxlc1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5pbm5lcldpZHRoIC0gV0lORE9XX1RPUF9PRkZTRVQpIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUHJlc3MoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9kcmF3ZXJSZWZfY3VycmVudDtcbiAgICAgICAgaWYgKCFkaXNtaXNzaWJsZSAmJiAhc25hcFBvaW50cykgcmV0dXJuO1xuICAgICAgICBpZiAoZHJhd2VyUmVmLmN1cnJlbnQgJiYgIWRyYXdlclJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgZHJhd2VySGVpZ2h0UmVmLmN1cnJlbnQgPSAoKF9kcmF3ZXJSZWZfY3VycmVudCA9IGRyYXdlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RyYXdlclJlZl9jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCkgfHwgMDtcbiAgICAgICAgc2V0SXNEcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgZHJhZ1N0YXJ0VGltZS5jdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgICAgICAgLy8gaU9TIGRvZXNuJ3QgdHJpZ2dlciBtb3VzZVVwIGFmdGVyIHNjcm9sbGluZyBzbyB3ZSBuZWVkIHRvIGxpc3RlbiB0byB0b3VjaGVkIGluIG9yZGVyIHRvIGRpc2FsbG93IGRyYWdnaW5nXG4gICAgICAgIGlmIChpc0lPUygpKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoKT0+aXNBbGxvd2VkVG9EcmFnLmN1cnJlbnQgPSBmYWxzZSwge1xuICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBtYWludGFpbiBjb3JyZWN0IHBvaW50ZXIgY2FwdHVyZSBldmVuIHdoZW4gZ29pbmcgb3V0c2lkZSBvZiB0aGUgZHJhd2VyXG4gICAgICAgIGV2ZW50LnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICBwb2ludGVyU3RhcnQuY3VycmVudCA9IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGV2ZW50LmNsaWVudFkgOiBldmVudC5jbGllbnRYO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGREcmFnKGVsLCBpc0RyYWdnaW5nSW5EaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIF93aW5kb3dfZ2V0U2VsZWN0aW9uO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGVsO1xuICAgICAgICBjb25zdCBoaWdobGlnaHRlZFRleHQgPSAoX3dpbmRvd19nZXRTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93X2dldFNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBzd2lwZUFtb3VudCA9IGRyYXdlclJlZi5jdXJyZW50ID8gZ2V0VHJhbnNsYXRlKGRyYXdlclJlZi5jdXJyZW50LCBkaXJlY3Rpb24pIDogbnVsbDtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS12YXVsLW5vLWRyYWcnKSB8fCBlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLXZhdWwtbm8tZHJhZ10nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IHNjcm9sbGluZyB3aGVuIGFuaW1hdGluZ1xuICAgICAgICBpZiAob3BlblRpbWUuY3VycmVudCAmJiBkYXRlLmdldFRpbWUoKSAtIG9wZW5UaW1lLmN1cnJlbnQuZ2V0VGltZSgpIDwgNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN3aXBlQW1vdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHN3aXBlQW1vdW50ID4gMCA6IHN3aXBlQW1vdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGRyYWcgaWYgdGhlcmUncyBoaWdobGlnaHRlZCB0ZXh0XG4gICAgICAgIGlmIChoaWdobGlnaHRlZFRleHQgJiYgaGlnaGxpZ2h0ZWRUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNhbGxvdyBkcmFnZ2luZyBpZiBkcmF3ZXIgd2FzIHNjcm9sbGVkIHdpdGhpbiBgc2Nyb2xsTG9ja1RpbWVvdXRgXG4gICAgICAgIGlmIChsYXN0VGltZURyYWdQcmV2ZW50ZWQuY3VycmVudCAmJiBkYXRlLmdldFRpbWUoKSAtIGxhc3RUaW1lRHJhZ1ByZXZlbnRlZC5jdXJyZW50LmdldFRpbWUoKSA8IHNjcm9sbExvY2tUaW1lb3V0ICYmIHN3aXBlQW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICBsYXN0VGltZURyYWdQcmV2ZW50ZWQuY3VycmVudCA9IGRhdGU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRHJhZ2dpbmdJbkRpcmVjdGlvbikge1xuICAgICAgICAgICAgbGFzdFRpbWVEcmFnUHJldmVudGVkLmN1cnJlbnQgPSBkYXRlO1xuICAgICAgICAgICAgLy8gV2UgYXJlIGRyYWdnaW5nIGRvd24gc28gd2Ugc2hvdWxkIGFsbG93IHNjcm9sbGluZ1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgY2xpbWJpbmcgdXAgdGhlIERPTSB0cmVlIGFzIGxvbmcgYXMgdGhlcmUncyBhIHBhcmVudFxuICAgICAgICB3aGlsZShlbGVtZW50KXtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHNjcm9sbGFibGVcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnNjcm9sbEhlaWdodCA+IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lRHJhZ1ByZXZlbnRlZC5jdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZSBhbmQgbm90IHNjcm9sbGVkIHRvIHRoZSB0b3AsIHNvIGRvbid0IGRyYWdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ2RpYWxvZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW92ZSB1cCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc2Nyb2xsYWJsZSBwYXJlbnRzIG5vdCBzY3JvbGxlZCB0byB0aGUgdG9wIGZvdW5kLCBzbyBkcmFnXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkRyYWcoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFkcmF3ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga25vdyBob3cgbXVjaCBvZiB0aGUgZHJhd2VyIGhhcyBiZWVuIGRyYWdnZWQgaW4gcGVyY2VudGFnZXMgc28gdGhhdCB3ZSBjYW4gdHJhbnNmb3JtIGJhY2tncm91bmQgYWNjb3JkaW5nbHlcbiAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbk11bHRpcGxpZXIgPSBkaXJlY3Rpb24gPT09ICdib3R0b20nIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IDEgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdnZWREaXN0YW5jZSA9IChwb2ludGVyU3RhcnQuY3VycmVudCAtIChpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBldmVudC5jbGllbnRZIDogZXZlbnQuY2xpZW50WCkpICogZGlyZWN0aW9uTXVsdGlwbGllcjtcbiAgICAgICAgICAgIGNvbnN0IGlzRHJhZ2dpbmdJbkRpcmVjdGlvbiA9IGRyYWdnZWREaXN0YW5jZSA+IDA7XG4gICAgICAgICAgICAvLyBQcmUgY29uZGl0aW9uIGZvciBkaXNhbGxvd2luZyBkcmFnZ2luZyBpbiB0aGUgY2xvc2UgZGlyZWN0aW9uLlxuICAgICAgICAgICAgY29uc3Qgbm9DbG9zZVNuYXBQb2ludHNQcmVDb25kaXRpb24gPSBzbmFwUG9pbnRzICYmICFkaXNtaXNzaWJsZSAmJiAhaXNEcmFnZ2luZ0luRGlyZWN0aW9uO1xuICAgICAgICAgICAgLy8gRGlzYWxsb3cgZHJhZ2dpbmcgZG93biB0byBjbG9zZSB3aGVuIGZpcnN0IHNuYXAgcG9pbnQgaXMgdGhlIGFjdGl2ZSBvbmUgYW5kIGRpc21pc3NpYmxlIHByb3AgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAgICAgICAgaWYgKG5vQ2xvc2VTbmFwUG9pbnRzUHJlQ29uZGl0aW9uICYmIGFjdGl2ZVNuYXBQb2ludEluZGV4ID09PSAwKSByZXR1cm47XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNhcHR1cmUgbGFzdCB0aW1lIHdoZW4gZHJhZyB3aXRoIHNjcm9sbCB3YXMgdHJpZ2dlcmVkIGFuZCBoYXZlIGEgdGltZW91dCBiZXR3ZWVuXG4gICAgICAgICAgICBjb25zdCBhYnNEcmFnZ2VkRGlzdGFuY2UgPSBNYXRoLmFicyhkcmFnZ2VkRGlzdGFuY2UpO1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1t2YXVsLWRyYXdlci13cmFwcGVyXScpO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIGRyYWdnZWQsIHdoZXJlIDEgaXMgdGhlIGNsb3NlZCBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IHBlcmNlbnRhZ2VEcmFnZ2VkID0gYWJzRHJhZ2dlZERpc3RhbmNlIC8gZHJhd2VySGVpZ2h0UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBzbmFwUG9pbnRQZXJjZW50YWdlRHJhZ2dlZCA9IGdldFNuYXBQb2ludHNQZXJjZW50YWdlRHJhZ2dlZChhYnNEcmFnZ2VkRGlzdGFuY2UsIGlzRHJhZ2dpbmdJbkRpcmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc25hcFBvaW50UGVyY2VudGFnZURyYWdnZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlRHJhZ2dlZCA9IHNuYXBQb2ludFBlcmNlbnRhZ2VEcmFnZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgY2xvc2UgZHJhZ2dpbmcgYmV5b25kIHRoZSBzbWFsbGVzdCBzbmFwIHBvaW50LlxuICAgICAgICAgICAgaWYgKG5vQ2xvc2VTbmFwUG9pbnRzUHJlQ29uZGl0aW9uICYmIHBlcmNlbnRhZ2VEcmFnZ2VkID49IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZFRvRHJhZy5jdXJyZW50ICYmICFzaG91bGREcmFnKGV2ZW50LnRhcmdldCwgaXNEcmFnZ2luZ0luRGlyZWN0aW9uKSkgcmV0dXJuO1xuICAgICAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZChEUkFHX0NMQVNTKTtcbiAgICAgICAgICAgIC8vIElmIHNob3VsZERyYWcgZ2F2ZSB0cnVlIG9uY2UgYWZ0ZXIgcHJlc3NpbmcgZG93biBvbiB0aGUgZHJhd2VyLCB3ZSBzZXQgaXNBbGxvd2VkVG9EcmFnIHRvIHRydWUgYW5kIGl0IHdpbGwgcmVtYWluIHRydWUgdW50aWwgd2UgbGV0IGdvLCB0aGVyZSdzIG5vIHJlYXNvbiB0byBkaXNhYmxlIGRyYWdnaW5nIG1pZCB3YXksIGV2ZXIsIGFuZCB0aGF0J3MgdGhlIHNvbHV0aW9uIHRvIGl0XG4gICAgICAgICAgICBpc0FsbG93ZWRUb0RyYWcuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0KG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc25hcFBvaW50cykge1xuICAgICAgICAgICAgICAgIG9uRHJhZ1NuYXBQb2ludHMoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkRGlzdGFuY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJ1biB0aGlzIG9ubHkgaWYgc25hcFBvaW50cyBhcmUgbm90IGRlZmluZWQgb3IgaWYgd2UgYXJlIGF0IHRoZSBsYXN0IHNuYXAgcG9pbnQgKGhpZ2hlc3Qgb25lKVxuICAgICAgICAgICAgaWYgKGlzRHJhZ2dpbmdJbkRpcmVjdGlvbiAmJiAhc25hcFBvaW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhbXBlbmVkRHJhZ2dlZERpc3RhbmNlID0gZGFtcGVuVmFsdWUoZHJhZ2dlZERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IE1hdGgubWluKGRhbXBlbmVkRHJhZ2dlZERpc3RhbmNlICogLTEsIDApICogZGlyZWN0aW9uTXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgdHJhbnNsYXRlM2QoMCwgJHt0cmFuc2xhdGVWYWx1ZX1weCwgMClgIDogYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlVmFsdWV9cHgsIDAsIDApYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHlWYWx1ZSA9IDEgLSBwZXJjZW50YWdlRHJhZ2dlZDtcbiAgICAgICAgICAgIGlmIChzaG91bGRGYWRlIHx8IGZhZGVGcm9tSW5kZXggJiYgYWN0aXZlU25hcFBvaW50SW5kZXggPT09IGZhZGVGcm9tSW5kZXggLSAxKSB7XG4gICAgICAgICAgICAgICAgb25EcmFnUHJvcCA9PSBudWxsID8gdm9pZCAwIDogb25EcmFnUHJvcChldmVudCwgcGVyY2VudGFnZURyYWdnZWQpO1xuICAgICAgICAgICAgICAgIHNldChvdmVybGF5UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogYCR7b3BhY2l0eVZhbHVlfWAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgb3ZlcmxheVJlZi5jdXJyZW50ICYmIHNob3VsZFNjYWxlQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlRHJhZ2dlZCBhcyBhIGZyYWN0aW9uICgwIHRvIDEpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVWYWx1ZSA9IE1hdGgubWluKGdldFNjYWxlKCkgKyBwZXJjZW50YWdlRHJhZ2dlZCAqICgxIC0gZ2V0U2NhbGUoKSksIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvcmRlclJhZGl1c1ZhbHVlID0gOCAtIHBlcmNlbnRhZ2VEcmFnZ2VkICogODtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IE1hdGgubWF4KDAsIDE0IC0gcGVyY2VudGFnZURyYWdnZWQgKiAxNCk7XG4gICAgICAgICAgICAgICAgc2V0KHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBgJHtib3JkZXJSYWRpdXNWYWx1ZX1weGAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHNjYWxlKCR7c2NhbGVWYWx1ZX0pIHRyYW5zbGF0ZTNkKDAsICR7dHJhbnNsYXRlVmFsdWV9cHgsIDApYCA6IGBzY2FsZSgke3NjYWxlVmFsdWV9KSB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVZhbHVlfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlVmFsdWUgPSBhYnNEcmFnZ2VkRGlzdGFuY2UgKiBkaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGB0cmFuc2xhdGUzZCgwLCAke3RyYW5zbGF0ZVZhbHVlfXB4LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVWYWx1ZX1weCwgMCwgMClgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgc2NhbGVCYWNrZ3JvdW5kKGZhbHNlKTtcbiAgICAgICAgICAgIHJlc3RvcmVQb3NpdGlvblNldHRpbmcoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHZhciBfd2luZG93X3Zpc3VhbFZpZXdwb3J0O1xuICAgICAgICBmdW5jdGlvbiBvblZpc3VhbFZpZXdwb3J0Q2hhbmdlKCkge1xuICAgICAgICAgICAgaWYgKCFkcmF3ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGlzSW5wdXQoZm9jdXNlZEVsZW1lbnQpIHx8IGtleWJvYXJkSXNPcGVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3dpbmRvd192aXN1YWxWaWV3cG9ydDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEhlaWdodCA9ICgoX3dpbmRvd192aXN1YWxWaWV3cG9ydCA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3dfdmlzdWFsVmlld3BvcnQuaGVpZ2h0KSB8fCAwO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGhlaWdodCBvZiB0aGUga2V5Ym9hcmRcbiAgICAgICAgICAgICAgICBsZXQgZGlmZkZyb21Jbml0aWFsID0gd2luZG93LmlubmVySGVpZ2h0IC0gdmlzdWFsVmlld3BvcnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd2VySGVpZ2h0ID0gZHJhd2VyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFpbml0aWFsRHJhd2VySGVpZ2h0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERyYXdlckhlaWdodC5jdXJyZW50ID0gZHJhd2VySGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRGcm9tVG9wID0gZHJhd2VyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgICAgICAgIC8vIHZpc3VhbFZpZXdwb3J0IGhlaWdodCBtYXkgY2hhbmdlIGR1ZSB0byBzb21lIHN1YnRsZSBjaGFuZ2VzIHRvIHRoZSBrZXlib2FyZC4gQ2hlY2tpbmcgaWYgdGhlIGhlaWdodCBjaGFuZ2VkIGJ5IDYwIG9yIG1vcmUgd2lsbCBtYWtlIHN1cmUgdGhhdCB0aGV5IGtleWJvYXJkIHJlYWxseSBjaGFuZ2VkIGl0cyBvcGVuIHN0YXRlLlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwcmV2aW91c0RpZmZGcm9tSW5pdGlhbC5jdXJyZW50IC0gZGlmZkZyb21Jbml0aWFsKSA+IDYwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkSXNPcGVuLmN1cnJlbnQgPSAha2V5Ym9hcmRJc09wZW4uY3VycmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBQb2ludHMgJiYgc25hcFBvaW50cy5sZW5ndGggPiAwICYmIHNuYXBQb2ludHNPZmZzZXQgJiYgYWN0aXZlU25hcFBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlU25hcFBvaW50SGVpZ2h0ID0gc25hcFBvaW50c09mZnNldFthY3RpdmVTbmFwUG9pbnRJbmRleF0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgZGlmZkZyb21Jbml0aWFsICs9IGFjdGl2ZVNuYXBQb2ludEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNEaWZmRnJvbUluaXRpYWwuY3VycmVudCA9IGRpZmZGcm9tSW5pdGlhbDtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIGNoYW5nZSB0aGUgaGVpZ2h0IGlmIHRoZSBpbnB1dCBpcyBpbiB2aWV3LCB3aGVuIHdlIGFyZSBoZXJlIHdlIGFyZSBpbiB0aGUgb3BlbmVkIGtleWJvYXJkIHN0YXRlIHNvIHdlIGNhbiBjb3JyZWN0bHkgY2hlY2sgaWYgdGhlIGlucHV0IGlzIGluIHZpZXdcbiAgICAgICAgICAgICAgICBpZiAoZHJhd2VySGVpZ2h0ID4gdmlzdWFsVmlld3BvcnRIZWlnaHQgfHwga2V5Ym9hcmRJc09wZW4uY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBkcmF3ZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdEcmF3ZXJIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPiB2aXN1YWxWaWV3cG9ydEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHJhd2VySGVpZ2h0ID0gdmlzdWFsVmlld3BvcnRIZWlnaHQgLSBXSU5ET1dfVE9QX09GRlNFVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGZpeGVkLCBkb24ndCBtb3ZlIHRoZSBkcmF3ZXIgdXB3YXJkcyBpZiB0aGVyZSdzIHNwYWNlLCBidXQgcmF0aGVyIG9ubHkgY2hhbmdlIGl0J3MgaGVpZ2h0IHNvIGl0J3MgZnVsbHkgc2Nyb2xsYWJsZSB3aGVuIHRoZSBrZXlib2FyZCBpcyBvcGVuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0IC0gTWF0aC5tYXgoZGlmZkZyb21Jbml0aWFsLCAwKX1weGA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtNYXRoLm1heChuZXdEcmF3ZXJIZWlnaHQsIHZpc3VhbFZpZXdwb3J0SGVpZ2h0IC0gb2Zmc2V0RnJvbVRvcCl9cHhgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7aW5pdGlhbERyYXdlckhlaWdodC5jdXJyZW50fXB4YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBQb2ludHMgJiYgc25hcFBvaW50cy5sZW5ndGggPiAwICYmICFrZXlib2FyZElzT3Blbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdlclJlZi5jdXJyZW50LnN0eWxlLmJvdHRvbSA9IGAwcHhgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZ2F0aXZlIGJvdHRvbSB2YWx1ZSB3b3VsZCBuZXZlciBtYWtlIHNlbnNlXG4gICAgICAgICAgICAgICAgICAgIGRyYXdlclJlZi5jdXJyZW50LnN0eWxlLmJvdHRvbSA9IGAke01hdGgubWF4KGRpZmZGcm9tSW5pdGlhbCwgMCl9cHhgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX3dpbmRvd192aXN1YWxWaWV3cG9ydCA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3dfdmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25WaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdmFyIF93aW5kb3dfdmlzdWFsVmlld3BvcnQ7XG4gICAgICAgICAgICByZXR1cm4gKF93aW5kb3dfdmlzdWFsVmlld3BvcnQgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93X3Zpc3VhbFZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uVmlzdWFsVmlld3BvcnRDaGFuZ2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgYWN0aXZlU25hcFBvaW50SW5kZXgsXG4gICAgICAgIHNuYXBQb2ludHMsXG4gICAgICAgIHNuYXBQb2ludHNPZmZzZXRcbiAgICBdKTtcbiAgICBmdW5jdGlvbiBjbG9zZURyYXdlcigpIHtcbiAgICAgICAgaWYgKCFkcmF3ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBjYW5jZWxEcmFnKCk7XG4gICAgICAgIG9uQ2xvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2xvc2UoKTtcbiAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGB0cmFuc2xhdGUzZCgwLCAke2RpcmVjdGlvbiA9PT0gJ2JvdHRvbScgPyAnMTAwJScgOiAnLTEwMCUnfSwgMClgIDogYHRyYW5zbGF0ZTNkKCR7ZGlyZWN0aW9uID09PSAncmlnaHQnID8gJzEwMCUnIDogJy0xMDAlJ30sIDAsIDApYCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGB0cmFuc2Zvcm0gJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgIH0pO1xuICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAnMCcsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWBcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlQmFja2dyb3VuZChmYWxzZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIHNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgc2V0SXNPcGVuKGZhbHNlKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgLy8gcmVzZXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnc2Nyb2xsQmVoYXZpb3InKTtcbiAgICAgICAgICAgIGlmIChzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50KHNuYXBQb2ludHNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBUUkFOU0lUSU9OUy5EVVJBVElPTiAqIDEwMDApOyAvLyBzZWNvbmRzIHRvIG1zXG4gICAgfVxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIWlzT3BlbiAmJiBzaG91bGRTY2FsZUJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIC8vIENhbid0IHVzZSBgb25BbmltYXRpb25FbmRgIGFzIHRoZSBjb21wb25lbnQgd2lsbCBiZSBpbnZpc2libGUgYnkgdGhlblxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgcmVzZXQoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgcmV0dXJuICgpPT5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIHNob3VsZFNjYWxlQmFja2dyb3VuZFxuICAgIF0pO1xuICAgIC8vIExheW91dEVmZmVjdCB0byBwcmV2ZW50IGV4dHJhIHJlbmRlciB3aGVyZSBvcGVuUHJvcCBhbmQgaXNPcGVuIGFyZSBub3Qgc3luY2VkIHlldFxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAob3BlblByb3ApIHtcbiAgICAgICAgICAgIHNldElzT3Blbih0cnVlKTtcbiAgICAgICAgICAgIHNldEhhc0JlZW5PcGVuZWQodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvcGVuUHJvcFxuICAgIF0pO1xuICAgIC8vIFRoaXMgY2FuIGJlIGRvbmUgbXVjaCBiZXR0ZXJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb25PcGVuQ2hhbmdlKGlzT3Blbik7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzT3BlblxuICAgIF0pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBzZXRNb3VudGVkKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICBmdW5jdGlvbiByZXNldERyYXdlcigpIHtcbiAgICAgICAgaWYgKCFkcmF3ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3ZhdWwtZHJhd2VyLXdyYXBwZXJdJyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTd2lwZUFtb3VudCA9IGdldFRyYW5zbGF0ZShkcmF3ZXJSZWYuY3VycmVudCwgZGlyZWN0aW9uKTtcbiAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7VFJBTlNJVElPTlMuRFVSQVRJT059cyBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgb3BhY2l0eTogJzEnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEb24ndCByZXNldCBiYWNrZ3JvdW5kIGlmIHN3aXBlZCB1cHdhcmRzXG4gICAgICAgIGlmIChzaG91bGRTY2FsZUJhY2tncm91bmQgJiYgY3VycmVudFN3aXBlQW1vdW50ICYmIGN1cnJlbnRTd2lwZUFtb3VudCA+IDAgJiYgaXNPcGVuKSB7XG4gICAgICAgICAgICBzZXQod3JhcHBlciwge1xuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogYCR7Qk9SREVSX1JBRElVU31weGAsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIC4uLmlzVmVydGljYWwoZGlyZWN0aW9uKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtnZXRTY2FsZSgpfSkgdHJhbnNsYXRlM2QoMCwgY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCkgKyAxNHB4KSwgMClgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AnXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtnZXRTY2FsZSgpfSkgdHJhbnNsYXRlM2QoY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCkgKyAxNHB4KSwgMCwgMClgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICdsZWZ0J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiAndHJhbnNmb3JtLCBib3JkZXItcmFkaXVzJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXNgLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogYGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxEcmFnKCkge1xuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcgfHwgIWRyYXdlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGRyYXdlclJlZi5jdXJyZW50LmNsYXNzTGlzdC5yZW1vdmUoRFJBR19DTEFTUyk7XG4gICAgICAgIGlzQWxsb3dlZFRvRHJhZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHNldElzRHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICBkcmFnRW5kVGltZS5jdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25SZWxlYXNlKGV2ZW50KSB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhZHJhd2VyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZShEUkFHX0NMQVNTKTtcbiAgICAgICAgaXNBbGxvd2VkVG9EcmFnLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgIGRyYWdFbmRUaW1lLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBzd2lwZUFtb3VudCA9IGdldFRyYW5zbGF0ZShkcmF3ZXJSZWYuY3VycmVudCwgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKCFzaG91bGREcmFnKGV2ZW50LnRhcmdldCwgZmFsc2UpIHx8ICFzd2lwZUFtb3VudCB8fCBOdW1iZXIuaXNOYU4oc3dpcGVBbW91bnQpKSByZXR1cm47XG4gICAgICAgIGlmIChkcmFnU3RhcnRUaW1lLmN1cnJlbnQgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGltZVRha2VuID0gZHJhZ0VuZFRpbWUuY3VycmVudC5nZXRUaW1lKCkgLSBkcmFnU3RhcnRUaW1lLmN1cnJlbnQuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBkaXN0TW92ZWQgPSBwb2ludGVyU3RhcnQuY3VycmVudCAtIChpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBldmVudC5jbGllbnRZIDogZXZlbnQuY2xpZW50WCk7XG4gICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gTWF0aC5hYnMoZGlzdE1vdmVkKSAvIHRpbWVUYWtlbjtcbiAgICAgICAgaWYgKHZlbG9jaXR5ID4gMC4wNSkge1xuICAgICAgICAgICAgLy8gYGp1c3RSZWxlYXNlZGAgaXMgbmVlZGVkIHRvIHByZXZlbnQgdGhlIGRyYXdlciBmcm9tIGZvY3VzaW5nIG9uIGFuIGlucHV0IHdoZW4gdGhlIGRyYWcgZW5kcywgYXMgaXQncyBub3QgdGhlIGludGVudCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgICAgICAgICAgc2V0SnVzdFJlbGVhc2VkKHRydWUpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIHNldEp1c3RSZWxlYXNlZChmYWxzZSk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25NdWx0aXBsaWVyID0gZGlyZWN0aW9uID09PSAnYm90dG9tJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyAxIDogLTE7XG4gICAgICAgICAgICBvblJlbGVhc2VTbmFwUG9pbnRzKHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRGlzdGFuY2U6IGRpc3RNb3ZlZCAqIGRpcmVjdGlvbk11bHRpcGxpZXIsXG4gICAgICAgICAgICAgICAgY2xvc2VEcmF3ZXIsXG4gICAgICAgICAgICAgICAgdmVsb2NpdHksXG4gICAgICAgICAgICAgICAgZGlzbWlzc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25SZWxlYXNlUHJvcCA9PSBudWxsID8gdm9pZCAwIDogb25SZWxlYXNlUHJvcChldmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW92ZWQgdXB3YXJkcywgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnID8gZGlzdE1vdmVkID4gMCA6IGRpc3RNb3ZlZCA8IDApIHtcbiAgICAgICAgICAgIHJlc2V0RHJhd2VyKCk7XG4gICAgICAgICAgICBvblJlbGVhc2VQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvblJlbGVhc2VQcm9wKGV2ZW50LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVsb2NpdHkgPiBWRUxPQ0lUWV9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIGNsb3NlRHJhd2VyKCk7XG4gICAgICAgICAgICBvblJlbGVhc2VQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvblJlbGVhc2VQcm9wKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9kcmF3ZXJSZWZfY3VycmVudF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfaGVpZ2h0O1xuICAgICAgICBjb25zdCB2aXNpYmxlRHJhd2VySGVpZ2h0ID0gTWF0aC5taW4oKF9kcmF3ZXJSZWZfY3VycmVudF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfaGVpZ2h0ID0gZHJhd2VyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KSAhPSBudWxsID8gX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF9oZWlnaHQgOiAwLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICBpZiAoc3dpcGVBbW91bnQgPj0gdmlzaWJsZURyYXdlckhlaWdodCAqIGNsb3NlVGhyZXNob2xkKSB7XG4gICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICAgICAgb25SZWxlYXNlUHJvcCA9PSBudWxsID8gdm9pZCAwIDogb25SZWxlYXNlUHJvcChldmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uUmVsZWFzZVByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVsZWFzZVByb3AoZXZlbnQsIHRydWUpO1xuICAgICAgICByZXNldERyYXdlcigpO1xuICAgIH1cbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gVHJpZ2dlciBlbnRlciBhbmltYXRpb24gd2l0aG91dCB1c2luZyBDU1MgYW5pbWF0aW9uXG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIHNldChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxCZWhhdmlvcjogJ2F1dG8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wZW5UaW1lLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgc2NhbGVCYWNrZ3JvdW5kKHRydWUpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc09wZW5cbiAgICBdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGRyYXdlclJlZi5jdXJyZW50ICYmIHZpc2libGUpIHtcbiAgICAgICAgICAgIHZhciBfZHJhd2VyUmVmX2N1cnJlbnQ7XG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBzY3JvbGxhYmxlIGVsZW1lbnRzIGluc2lkZSBvdXIgZHJhd2VyIGFuZCBhc3NpZ24gYSBjbGFzcyB0byBpdCBzbyB0aGF0IHdlIGNhbiBkaXNhYmxlIG92ZXJmbG93IHdoZW4gZHJhZ2dpbmcgdG8gcHJldmVudCBwb2ludGVybW92ZSBub3QgYmVpbmcgY2FwdHVyZWRcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZHJhd2VyUmVmID09IG51bGwgPyB2b2lkIDAgOiAoX2RyYXdlclJlZl9jdXJyZW50ID0gZHJhd2VyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhd2VyUmVmX2N1cnJlbnQucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuICAgICAgICAgICAgY2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChodG1sQ2hpbGQuc2Nyb2xsSGVpZ2h0ID4gaHRtbENoaWxkLmNsaWVudEhlaWdodCB8fCBodG1sQ2hpbGQuc2Nyb2xsV2lkdGggPiBodG1sQ2hpbGQuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbENoaWxkLmNsYXNzTGlzdC5hZGQoJ3ZhdWwtc2Nyb2xsYWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgZnVuY3Rpb24gc2NhbGVCYWNrZ3JvdW5kKG9wZW4pIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1t2YXVsLWRyYXdlci13cmFwcGVyXScpO1xuICAgICAgICBpZiAoIXdyYXBwZXIgfHwgIXNob3VsZFNjYWxlQmFja2dyb3VuZCkgcmV0dXJuO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgaWYgKHNldEJhY2tncm91bmRDb2xvck9uU2NhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vQm9keVN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIG9yaWdpbmFsIHN0eWxlcyBpbml0aWFsbHlcbiAgICAgICAgICAgICAgICAgICAgc2V0KGRvY3VtZW50LmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yIHx8IGRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyBib2R5IHN0eWxlcywgd2l0aCBjYWNoZSBpZ25vcmVkLCBzbyB0aGF0IHdlIGNhbiBnZXQgY29ycmVjdCBvcmlnaW5hbCBzdHlsZXMgaW4gcmVzZXRcbiAgICAgICAgICAgICAgICAgICAgc2V0KGRvY3VtZW50LmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdibGFjaydcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0KHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGAke0JPUkRFUl9SQURJVVN9cHhgLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAuLi5pc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7Z2V0U2NhbGUoKX0pIHRyYW5zbGF0ZTNkKDAsIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC10b3ApICsgMTRweCksIDApYCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAndG9wJ1xuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7Z2V0U2NhbGUoKX0pIHRyYW5zbGF0ZTNkKGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC10b3ApICsgMTRweCksIDAsIDApYCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogJ3RyYW5zZm9ybSwgYm9yZGVyLXJhZGl1cycsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zYCxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFeGl0XG4gICAgICAgICAgICByZXNldCh3cmFwcGVyLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIHJlc2V0KHdyYXBwZXIsICd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgIHJlc2V0KHdyYXBwZXIsICdib3JkZXJSYWRpdXMnKTtcbiAgICAgICAgICAgIHNldCh3cmFwcGVyLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiAndHJhbnNmb3JtLCBib3JkZXItcmFkaXVzJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXNgLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogYGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk5lc3RlZE9wZW5DaGFuZ2Uobykge1xuICAgICAgICBjb25zdCBzY2FsZSA9IG8gPyAod2luZG93LmlubmVyV2lkdGggLSBORVNURURfRElTUExBQ0VNRU5UKSAvIHdpbmRvdy5pbm5lcldpZHRoIDogMTtcbiAgICAgICAgY29uc3QgeSA9IG8gPyAtTkVTVEVEX0RJU1BMQUNFTUVOVCA6IDA7XG4gICAgICAgIGlmIChuZXN0ZWRPcGVuQ2hhbmdlVGltZXIuY3VycmVudCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChuZXN0ZWRPcGVuQ2hhbmdlVGltZXIuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7VFJBTlNJVElPTlMuRFVSQVRJT059cyBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGV9KSB0cmFuc2xhdGUzZCgwLCAke3l9cHgsIDApYFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvICYmIGRyYXdlclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBuZXN0ZWRPcGVuQ2hhbmdlVGltZXIuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IGdldFRyYW5zbGF0ZShkcmF3ZXJSZWYuY3VycmVudCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGB0cmFuc2xhdGUzZCgwLCAke3RyYW5zbGF0ZVZhbHVlfXB4LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVWYWx1ZX1weCwgMCwgMClgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTmVzdGVkRHJhZyhldmVudCwgcGVyY2VudGFnZURyYWdnZWQpIHtcbiAgICAgICAgaWYgKHBlcmNlbnRhZ2VEcmFnZ2VkIDwgMCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbml0aWFsRGltID0gaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTY2FsZSA9IChpbml0aWFsRGltIC0gTkVTVEVEX0RJU1BMQUNFTUVOVCkgLyBpbml0aWFsRGltO1xuICAgICAgICBjb25zdCBuZXdTY2FsZSA9IGluaXRpYWxTY2FsZSArIHBlcmNlbnRhZ2VEcmFnZ2VkICogKDEgLSBpbml0aWFsU2NhbGUpO1xuICAgICAgICBjb25zdCBuZXdUcmFuc2xhdGUgPSAtTkVTVEVEX0RJU1BMQUNFTUVOVCArIHBlcmNlbnRhZ2VEcmFnZ2VkICogTkVTVEVEX0RJU1BMQUNFTUVOVDtcbiAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGBzY2FsZSgke25ld1NjYWxlfSkgdHJhbnNsYXRlM2QoMCwgJHtuZXdUcmFuc2xhdGV9cHgsIDApYCA6IGBzY2FsZSgke25ld1NjYWxlfSkgdHJhbnNsYXRlM2QoJHtuZXdUcmFuc2xhdGV9cHgsIDAsIDApYCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25OZXN0ZWRSZWxlYXNlKGV2ZW50LCBvKSB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjb25zdCBzY2FsZSA9IG8gPyAoZGltIC0gTkVTVEVEX0RJU1BMQUNFTUVOVCkgLyBkaW0gOiAxO1xuICAgICAgICBjb25zdCB0cmFuc2xhdGUgPSBvID8gLU5FU1RFRF9ESVNQTEFDRU1FTlQgOiAwO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYHRyYW5zZm9ybSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgc2NhbGUoJHtzY2FsZX0pIHRyYW5zbGF0ZTNkKDAsICR7dHJhbnNsYXRlfXB4LCAwKWAgOiBgc2NhbGUoJHtzY2FsZX0pIHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlfXB4LCAwLCAwKWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nUHJpbWl0aXZlLlJvb3QsIHtcbiAgICAgICAgbW9kYWw6IG1vZGFsLFxuICAgICAgICBvbk9wZW5DaGFuZ2U6IChvKT0+e1xuICAgICAgICAgICAgaWYgKG9wZW5Qcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uT3BlbkNoYW5nZShvKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRIYXNCZWVuT3BlbmVkKHRydWUpO1xuICAgICAgICAgICAgICAgIHNldElzT3BlbihvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3BlbjogaXNPcGVuXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERyYXdlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHZpc2libGUsXG4gICAgICAgICAgICBhY3RpdmVTbmFwUG9pbnQsXG4gICAgICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50LFxuICAgICAgICAgICAgZHJhd2VyUmVmLFxuICAgICAgICAgICAgb3ZlcmxheVJlZixcbiAgICAgICAgICAgIHNjYWxlQmFja2dyb3VuZCxcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSxcbiAgICAgICAgICAgIG9uUHJlc3MsXG4gICAgICAgICAgICBzZXRWaXNpYmxlLFxuICAgICAgICAgICAgb25SZWxlYXNlLFxuICAgICAgICAgICAgb25EcmFnLFxuICAgICAgICAgICAgZGlzbWlzc2libGUsXG4gICAgICAgICAgICBoYW5kbGVPbmx5LFxuICAgICAgICAgICAgaXNPcGVuLFxuICAgICAgICAgICAgaXNEcmFnZ2luZyxcbiAgICAgICAgICAgIHNob3VsZEZhZGUsXG4gICAgICAgICAgICBjbG9zZURyYXdlcixcbiAgICAgICAgICAgIG9uTmVzdGVkRHJhZyxcbiAgICAgICAgICAgIG9uTmVzdGVkT3BlbkNoYW5nZSxcbiAgICAgICAgICAgIG9uTmVzdGVkUmVsZWFzZSxcbiAgICAgICAgICAgIGtleWJvYXJkSXNPcGVuLFxuICAgICAgICAgICAgb3BlblByb3AsXG4gICAgICAgICAgICBtb2RhbCxcbiAgICAgICAgICAgIHNuYXBQb2ludHNPZmZzZXQsXG4gICAgICAgICAgICBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgIH0sIGNoaWxkcmVuKSk7XG59XG5jb25zdCBMT05HX0hBTkRMRV9QUkVTU19USU1FT1VUID0gMjUwO1xuY29uc3QgRE9VQkxFX1RBUF9USU1FT1VUID0gMTIwO1xuY29uc3QgSGFuZGxlID0gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKHsgcHJldmVudEN5Y2xlID0gZmFsc2UsIGNoaWxkcmVuLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgY2xvc2VEcmF3ZXIsIGlzRHJhZ2dpbmcsIHNuYXBQb2ludHMsIGFjdGl2ZVNuYXBQb2ludCwgc2V0QWN0aXZlU25hcFBvaW50LCBkaXNtaXNzaWJsZSwgaGFuZGxlT25seSwgb25QcmVzcywgb25EcmFnIH0gPSB1c2VEcmF3ZXJDb250ZXh0KCk7XG4gICAgY29uc3QgY2xvc2VUaW1lb3V0SWRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0Q3ljbGUoKSB7XG4gICAgICAgIC8vIFN0b3AgaWYgdGhpcyBpcyB0aGUgc2Vjb25kIGNsaWNrIG9mIGEgZG91YmxlIGNsaWNrXG4gICAgICAgIGlmIChzaG91bGRDYW5jZWxJbnRlcmFjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICBoYW5kbGVDeWNsZVNuYXBQb2ludHMoKTtcbiAgICAgICAgfSwgRE9VQkxFX1RBUF9USU1FT1VUKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQ3ljbGVTbmFwUG9pbnRzKCkge1xuICAgICAgICAvLyBQcmV2ZW50IGFjY2lkZW50YWwgdGFwcyB3aGlsZSByZXNpemluZyBkcmF3ZXJcbiAgICAgICAgaWYgKGlzRHJhZ2dpbmcgfHwgcHJldmVudEN5Y2xlIHx8IHNob3VsZENhbmNlbEludGVyYWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbEludGVyYWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGNsZWFyIHRoZSB0aW1lb3V0IGlkIGlmIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBoYW5kbGUgYmVmb3JlIHRoZSBjYW5jZWwgdGltZW91dFxuICAgICAgICBoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbigpO1xuICAgICAgICBpZiAoKCFzbmFwUG9pbnRzIHx8IHNuYXBQb2ludHMubGVuZ3RoID09PSAwKSAmJiBkaXNtaXNzaWJsZSkge1xuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0xhc3RTbmFwUG9pbnQgPSBhY3RpdmVTbmFwUG9pbnQgPT09IHNuYXBQb2ludHNbc25hcFBvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGlzTGFzdFNuYXBQb2ludCAmJiBkaXNtaXNzaWJsZSkge1xuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U25hcEluZGV4ID0gc25hcFBvaW50cy5maW5kSW5kZXgoKHBvaW50KT0+cG9pbnQgPT09IGFjdGl2ZVNuYXBQb2ludCk7XG4gICAgICAgIGlmIChjdXJyZW50U25hcEluZGV4ID09PSAtMSkgcmV0dXJuOyAvLyBhY3RpdmVTbmFwUG9pbnQgbm90IGZvdW5kIGluIHNuYXBQb2ludHNcbiAgICAgICAgY29uc3QgbmV4dFNuYXBQb2ludCA9IHNuYXBQb2ludHNbY3VycmVudFNuYXBJbmRleCArIDFdO1xuICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnQobmV4dFNuYXBQb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0SW50ZXJhY3Rpb24oKSB7XG4gICAgICAgIGNsb3NlVGltZW91dElkUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGNsaWNrIGludGVyYWN0aW9uIG9uIGEgbG9uZyBwcmVzc1xuICAgICAgICAgICAgc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sIExPTkdfSEFORExFX1BSRVNTX1RJTUVPVVQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbigpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChjbG9zZVRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgICAgc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgb25DbGljazogaGFuZGxlU3RhcnRDeWNsZSxcbiAgICAgICAgb25Eb3VibGVDbGljazogKCk9PntcbiAgICAgICAgICAgIHNob3VsZENhbmNlbEludGVyYWN0aW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyQ2FuY2VsOiBoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbixcbiAgICAgICAgb25Qb2ludGVyRG93bjogKGUpPT57XG4gICAgICAgICAgICBpZiAoaGFuZGxlT25seSkgb25QcmVzcyhlKTtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0SW50ZXJhY3Rpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZTogKGUpPT57XG4gICAgICAgICAgICBpZiAoaGFuZGxlT25seSkgb25EcmFnKGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBvblBvaW50ZXJVcCBpcyBhbHJlYWR5IGhhbmRsZWQgYnkgdGhlIGNvbnRlbnQgY29tcG9uZW50XG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBcInZhdWwtZHJhd2VyLXZpc2libGVcIjogdmlzaWJsZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgIFwidmF1bC1oYW5kbGVcIjogXCJcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICAgICAgLi4ucmVzdFxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBcInZhdWwtaGFuZGxlLWhpdGFyZWFcIjogXCJcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH0sIGNoaWxkcmVuKSk7XG59KTtcbkhhbmRsZS5kaXNwbGF5TmFtZSA9ICdEcmF3ZXIuSGFuZGxlJztcbmNvbnN0IE92ZXJsYXkgPSAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24oeyBjaGlsZHJlbiwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCB7IG92ZXJsYXlSZWYsIHNuYXBQb2ludHMsIG9uUmVsZWFzZSwgc2hvdWxkRmFkZSwgaXNPcGVuLCB2aXNpYmxlIH0gPSB1c2VEcmF3ZXJDb250ZXh0KCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWYgPSB1c2VDb21wb3NlZFJlZnMocmVmLCBvdmVybGF5UmVmKTtcbiAgICBjb25zdCBoYXNTbmFwUG9pbnRzID0gc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChEaWFsb2dQcmltaXRpdmUuT3ZlcmxheSwge1xuICAgICAgICBvbk1vdXNlVXA6IG9uUmVsZWFzZSxcbiAgICAgICAgcmVmOiBjb21wb3NlZFJlZixcbiAgICAgICAgXCJ2YXVsLWRyYXdlci12aXNpYmxlXCI6IHZpc2libGUgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICBcInZhdWwtb3ZlcmxheVwiOiBcIlwiLFxuICAgICAgICBcInZhdWwtc25hcC1wb2ludHNcIjogaXNPcGVuICYmIGhhc1NuYXBQb2ludHMgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICBcInZhdWwtc25hcC1wb2ludHMtb3ZlcmxheVwiOiBpc09wZW4gJiYgc2hvdWxkRmFkZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgIC4uLnJlc3RcbiAgICB9KTtcbn0pO1xuT3ZlcmxheS5kaXNwbGF5TmFtZSA9ICdEcmF3ZXIuT3ZlcmxheSc7XG5jb25zdCBDb250ZW50ID0gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKHsgb25PcGVuQXV0b0ZvY3VzLCBvblBvaW50ZXJEb3duT3V0c2lkZSwgb25BbmltYXRpb25FbmQsIHN0eWxlLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IHsgZHJhd2VyUmVmLCBvblByZXNzLCBvblJlbGVhc2UsIG9uRHJhZywgZGlzbWlzc2libGUsIGtleWJvYXJkSXNPcGVuLCBzbmFwUG9pbnRzT2Zmc2V0LCB2aXNpYmxlLCBjbG9zZURyYXdlciwgbW9kYWwsIG9wZW5Qcm9wLCBvbk9wZW5DaGFuZ2UsIHNldFZpc2libGUsIGhhbmRsZU9ubHksIGRpcmVjdGlvbiB9ID0gdXNlRHJhd2VyQ29udGV4dCgpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmID0gdXNlQ29tcG9zZWRSZWZzKHJlZiwgZHJhd2VyUmVmKTtcbiAgICBjb25zdCBwb2ludGVyU3RhcnRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgd2FzQmV5b25kVGhlUG9pbnRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGlzRGVsdGFJbkRpcmVjdGlvbiA9IChkZWx0YSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQgPSAwKT0+e1xuICAgICAgICBpZiAod2FzQmV5b25kVGhlUG9pbnRSZWYuY3VycmVudCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKGRlbHRhLnkpO1xuICAgICAgICBjb25zdCBkZWx0YVggPSBNYXRoLmFicyhkZWx0YS54KTtcbiAgICAgICAgY29uc3QgaXNEZWx0YVggPSBkZWx0YVggPiBkZWx0YVk7XG4gICAgICAgIGNvbnN0IGRGYWN0b3IgPSBbXG4gICAgICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgICAgICdyaWdodCdcbiAgICAgICAgXS5pbmNsdWRlcyhkaXJlY3Rpb24pID8gMSA6IC0xO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBjb25zdCBpc1JldmVyc2VEaXJlY3Rpb24gPSBkZWx0YS54ICogZEZhY3RvciA8IDA7XG4gICAgICAgICAgICBpZiAoIWlzUmV2ZXJzZURpcmVjdGlvbiAmJiBkZWx0YVggPj0gMCAmJiBkZWx0YVggPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGVsdGFYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNSZXZlcnNlRGlyZWN0aW9uID0gZGVsdGEueSAqIGRGYWN0b3IgPCAwO1xuICAgICAgICAgICAgaWYgKCFpc1JldmVyc2VEaXJlY3Rpb24gJiYgZGVsdGFZID49IDAgJiYgZGVsdGFZIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNEZWx0YVg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2FzQmV5b25kVGhlUG9pbnRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIFRyaWdnZXIgZW50ZXIgYW5pbWF0aW9uIHdpdGhvdXQgdXNpbmcgQ1NTIGFuaW1hdGlvblxuICAgICAgICBzZXRWaXNpYmxlKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERpYWxvZ1ByaW1pdGl2ZS5Db250ZW50LCB7XG4gICAgICAgIFwidmF1bC1kcmF3ZXJcIjogXCJcIixcbiAgICAgICAgXCJ2YXVsLWRyYXdlci1kaXJlY3Rpb25cIjogZGlyZWN0aW9uLFxuICAgICAgICBcInZhdWwtZHJhd2VyLXZpc2libGVcIjogdmlzaWJsZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIHJlZjogY29tcG9zZWRSZWYsXG4gICAgICAgIHN0eWxlOiBzbmFwUG9pbnRzT2Zmc2V0ICYmIHNuYXBQb2ludHNPZmZzZXQubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgICAgICctLXNuYXAtcG9pbnQtaGVpZ2h0JzogYCR7c25hcFBvaW50c09mZnNldFswXX1weGAsXG4gICAgICAgICAgICAuLi5zdHlsZVxuICAgICAgICB9IDogc3R5bGUsXG4gICAgICAgIG9uT3BlbkF1dG9Gb2N1czogKGUpPT57XG4gICAgICAgICAgICBpZiAob25PcGVuQXV0b0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgb25PcGVuQXV0b0ZvY3VzKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2RyYXdlclJlZl9jdXJyZW50O1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAoX2RyYXdlclJlZl9jdXJyZW50ID0gZHJhd2VyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhd2VyUmVmX2N1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bjogKGV2ZW50KT0+e1xuICAgICAgICAgICAgaWYgKGhhbmRsZU9ubHkpIHJldHVybjtcbiAgICAgICAgICAgIHJlc3Qub25Qb2ludGVyRG93biA9PSBudWxsID8gdm9pZCAwIDogcmVzdC5vblBvaW50ZXJEb3duLmNhbGwocmVzdCwgZXZlbnQpO1xuICAgICAgICAgICAgcG9pbnRlclN0YXJ0UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25QcmVzcyhldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlOiAoZSk9PntcbiAgICAgICAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlID09IG51bGwgPyB2b2lkIDAgOiBvblBvaW50ZXJEb3duT3V0c2lkZShlKTtcbiAgICAgICAgICAgIGlmICghbW9kYWwgfHwgZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlib2FyZElzT3Blbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAga2V5Ym9hcmRJc09wZW4uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFkaXNtaXNzaWJsZSB8fCBvcGVuUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1c091dHNpZGU6IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFtb2RhbCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXNjYXBlS2V5RG93bjogKGUpPT57XG4gICAgICAgICAgICBpZiAoIW1vZGFsKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZTogKGV2ZW50KT0+e1xuICAgICAgICAgICAgaWYgKGhhbmRsZU9ubHkpIHJldHVybjtcbiAgICAgICAgICAgIHJlc3Qub25Qb2ludGVyTW92ZSA9PSBudWxsID8gdm9pZCAwIDogcmVzdC5vblBvaW50ZXJNb3ZlLmNhbGwocmVzdCwgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFwb2ludGVyU3RhcnRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeVBvc2l0aW9uID0gZXZlbnQuY2xpZW50WSAtIHBvaW50ZXJTdGFydFJlZi5jdXJyZW50Lnk7XG4gICAgICAgICAgICBjb25zdCB4UG9zaXRpb24gPSBldmVudC5jbGllbnRYIC0gcG9pbnRlclN0YXJ0UmVmLmN1cnJlbnQueDtcbiAgICAgICAgICAgIGNvbnN0IHN3aXBlU3RhcnRUaHJlc2hvbGQgPSBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/IDEwIDogMjtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgICAgICAgICAgIHg6IHhQb3NpdGlvbixcbiAgICAgICAgICAgICAgICB5OiB5UG9zaXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpc0FsbG93ZWRUb1N3aXBlID0gaXNEZWx0YUluRGlyZWN0aW9uKGRlbHRhLCBkaXJlY3Rpb24sIHN3aXBlU3RhcnRUaHJlc2hvbGQpO1xuICAgICAgICAgICAgaWYgKGlzQWxsb3dlZFRvU3dpcGUpIG9uRHJhZyhldmVudCk7XG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyh4UG9zaXRpb24pID4gc3dpcGVTdGFydFRocmVzaG9sZCB8fCBNYXRoLmFicyh5UG9zaXRpb24pID4gc3dpcGVTdGFydFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJTdGFydFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyVXA6IChldmVudCk9PntcbiAgICAgICAgICAgIHJlc3Qub25Qb2ludGVyVXAgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3Qub25Qb2ludGVyVXAuY2FsbChyZXN0LCBldmVudCk7XG4gICAgICAgICAgICBwb2ludGVyU3RhcnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB3YXNCZXlvbmRUaGVQb2ludFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBvblJlbGVhc2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbkNvbnRlbnQuZGlzcGxheU5hbWUgPSAnRHJhd2VyLkNvbnRlbnQnO1xuZnVuY3Rpb24gTmVzdGVkUm9vdCh7IG9uRHJhZywgb25PcGVuQ2hhbmdlLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCB7IG9uTmVzdGVkRHJhZywgb25OZXN0ZWRPcGVuQ2hhbmdlLCBvbk5lc3RlZFJlbGVhc2UgfSA9IHVzZURyYXdlckNvbnRleHQoKTtcbiAgICBpZiAoIW9uTmVzdGVkRHJhZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYXdlci5OZXN0ZWRSb290IG11c3QgYmUgcGxhY2VkIGluIGFub3RoZXIgZHJhd2VyJyk7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUm9vdCwge1xuICAgICAgICBuZXN0ZWQ6IHRydWUsXG4gICAgICAgIG9uQ2xvc2U6ICgpPT57XG4gICAgICAgICAgICBvbk5lc3RlZE9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbkRyYWc6IChlLCBwKT0+e1xuICAgICAgICAgICAgb25OZXN0ZWREcmFnKGUsIHApO1xuICAgICAgICAgICAgb25EcmFnID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWcoZSwgcCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT3BlbkNoYW5nZTogKG8pPT57XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgIG9uTmVzdGVkT3BlbkNoYW5nZShvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb25PcGVuQ2hhbmdlKG8pO1xuICAgICAgICB9LFxuICAgICAgICBvblJlbGVhc2U6IG9uTmVzdGVkUmVsZWFzZSxcbiAgICAgICAgLi4ucmVzdFxuICAgIH0pO1xufVxuY29uc3QgRHJhd2VyID0ge1xuICAgIFJvb3QsXG4gICAgTmVzdGVkUm9vdCxcbiAgICBDb250ZW50LFxuICAgIEhhbmRsZSxcbiAgICBPdmVybGF5LFxuICAgIFRyaWdnZXI6IERpYWxvZ1ByaW1pdGl2ZS5UcmlnZ2VyLFxuICAgIFBvcnRhbDogRGlhbG9nUHJpbWl0aXZlLlBvcnRhbCxcbiAgICBDbG9zZTogRGlhbG9nUHJpbWl0aXZlLkNsb3NlLFxuICAgIFRpdGxlOiBEaWFsb2dQcmltaXRpdmUuVGl0bGUsXG4gICAgRGVzY3JpcHRpb246IERpYWxvZ1ByaW1pdGl2ZS5EZXNjcmlwdGlvblxufTtcblxuZXhwb3J0IHsgRHJhd2VyIH07XG4iXSwibmFtZXMiOlsiX19pbnNlcnRDU1MiLCJjb2RlIiwiZG9jdW1lbnQiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiYXBwZW5kQ2hpbGQiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiRGlhbG9nUHJpbWl0aXZlIiwiUmVhY3QiLCJSZWFjdF9fZGVmYXVsdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsIkRyYXdlckNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZHJhd2VyUmVmIiwiY3VycmVudCIsIm92ZXJsYXlSZWYiLCJzY2FsZUJhY2tncm91bmQiLCJvblByZXNzIiwib25SZWxlYXNlIiwib25EcmFnIiwib25OZXN0ZWREcmFnIiwib25OZXN0ZWRPcGVuQ2hhbmdlIiwib25OZXN0ZWRSZWxlYXNlIiwib3BlblByb3AiLCJ1bmRlZmluZWQiLCJkaXNtaXNzaWJsZSIsImhhbmRsZU9ubHkiLCJpc09wZW4iLCJpc0RyYWdnaW5nIiwia2V5Ym9hcmRJc09wZW4iLCJzbmFwUG9pbnRzT2Zmc2V0Iiwic25hcFBvaW50cyIsIm1vZGFsIiwic2hvdWxkRmFkZSIsImFjdGl2ZVNuYXBQb2ludCIsIm9uT3BlbkNoYW5nZSIsInNldEFjdGl2ZVNuYXBQb2ludCIsInZpc2libGUiLCJjbG9zZURyYXdlciIsInNldFZpc2libGUiLCJkaXJlY3Rpb24iLCJ1c2VEcmF3ZXJDb250ZXh0IiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJFcnJvciIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjaGFpbiIsImNhbGxiYWNrcyIsImFyZ3MiLCJjYWxsYmFjayIsImlzTWFjIiwidGVzdFBsYXRmb3JtIiwiaXNJUGhvbmUiLCJpc0lQYWQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsImlzSU9TIiwicmUiLCJ3aW5kb3ciLCJ0ZXN0IiwicGxhdGZvcm0iLCJ2aXN1YWxWaWV3cG9ydCIsImlzU2Nyb2xsYWJsZSIsIm5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJwYXJlbnRFbGVtZW50Iiwic2Nyb2xsaW5nRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsIm5vblRleHRJbnB1dFR5cGVzIiwiU2V0IiwicHJldmVudFNjcm9sbENvdW50IiwicmVzdG9yZSIsInVzZVByZXZlbnRTY3JvbGwiLCJvcHRpb25zIiwiaXNEaXNhYmxlZCIsInByZXZlbnRTY3JvbGxNb2JpbGVTYWZhcmkiLCJwcmV2ZW50U2Nyb2xsU3RhbmRhcmQiLCJzZXRTdHlsZSIsImlubmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsInNjcm9sbGFibGUiLCJsYXN0WSIsIm9uVG91Y2hTdGFydCIsImUiLCJ0YXJnZXQiLCJib2R5IiwiY2hhbmdlZFRvdWNoZXMiLCJwYWdlWSIsIm9uVG91Y2hNb3ZlIiwicHJldmVudERlZmF1bHQiLCJ5Iiwic2Nyb2xsVG9wIiwiYm90dG9tIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwib25Ub3VjaEVuZCIsImlzSW5wdXQiLCJhY3RpdmVFbGVtZW50IiwidHJhbnNmb3JtIiwiZm9jdXMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvbkZvY3VzIiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJzY3JvbGxJbnRvVmlldyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwib25XaW5kb3dTY3JvbGwiLCJzY3JvbGxUbyIsInNjcm9sbFgiLCJwYWdlWE9mZnNldCIsInNjcm9sbFkiLCJwYWdlWU9mZnNldCIsInJlc3RvcmVTdHlsZXMiLCJyZW1vdmVFdmVudHMiLCJhZGRFdmVudCIsInBhc3NpdmUiLCJjYXB0dXJlIiwiZWxlbWVudCIsInZhbHVlIiwiY3VyIiwiZXZlbnQiLCJoYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJvb3QiLCJzY3JvbGxhYmxlVG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwidGFyZ2V0VG9wIiwidGFyZ2V0Qm90dG9tIiwia2V5Ym9hcmRIZWlnaHQiLCJIVE1MSW5wdXRFbGVtZW50IiwiaGFzIiwiSFRNTFRleHRBcmVhRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNDb250ZW50RWRpdGFibGUiLCJzZXRSZWYiLCJyZWYiLCJjb21wb3NlUmVmcyIsInJlZnMiLCJmb3JFYWNoIiwidXNlQ29tcG9zZWRSZWZzIiwidXNlQ2FsbGJhY2siLCJwcmV2aW91c0JvZHlQb3NpdGlvbiIsInVzZVBvc2l0aW9uRml4ZWQiLCJuZXN0ZWQiLCJoYXNCZWVuT3BlbmVkIiwicHJldmVudFNjcm9sbFJlc3RvcmF0aW9uIiwibm9Cb2R5U3R5bGVzIiwiYWN0aXZlVXJsIiwic2V0QWN0aXZlVXJsIiwidXNlU3RhdGUiLCJsb2NhdGlvbiIsImhyZWYiLCJzY3JvbGxQb3MiLCJ1c2VSZWYiLCJzZXRQb3NpdGlvbkZpeGVkIiwicG9zaXRpb24iLCJsZWZ0IiwicmlnaHQiLCJzZXRQcm9wZXJ0eSIsIk9iamVjdCIsImFzc2lnbiIsInNldFRpbWVvdXQiLCJib3R0b21CYXJIZWlnaHQiLCJyZXN0b3JlUG9zaXRpb25TZXR0aW5nIiwicGFyc2VJbnQiLCJ4Iiwib25TY3JvbGwiLCJpc1N0YW5kYWxvbmUiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImNhY2hlIiwiV2Vha01hcCIsInNldCIsImVsIiwic3R5bGVzIiwiaWdub3JlQ2FjaGUiLCJvcmlnaW5hbFN0eWxlcyIsImVudHJpZXMiLCJrZXkiLCJzdGFydHNXaXRoIiwicmVzZXQiLCJwcm9wIiwiZ2V0IiwiaXNWZXJ0aWNhbCIsImdldFRyYW5zbGF0ZSIsIndlYmtpdFRyYW5zZm9ybSIsIm1velRyYW5zZm9ybSIsIm1hdCIsIm1hdGNoIiwicGFyc2VGbG9hdCIsInNwbGl0IiwiZGFtcGVuVmFsdWUiLCJ2IiwiTWF0aCIsImxvZyIsIlRSQU5TSVRJT05TIiwiRFVSQVRJT04iLCJFQVNFIiwiVkVMT0NJVFlfVEhSRVNIT0xEIiwidXNlQ2FsbGJhY2tSZWYiLCJjYWxsYmFja1JlZiIsInVzZU1lbW8iLCJjYWxsIiwidXNlVW5jb250cm9sbGVkU3RhdGUiLCJkZWZhdWx0UHJvcCIsIm9uQ2hhbmdlIiwidW5jb250cm9sbGVkU3RhdGUiLCJwcmV2VmFsdWVSZWYiLCJoYW5kbGVDaGFuZ2UiLCJ1c2VDb250cm9sbGFibGVTdGF0ZSIsInVuY29udHJvbGxlZFByb3AiLCJzZXRVbmNvbnRyb2xsZWRQcm9wIiwiaXNDb250cm9sbGVkIiwic2V0VmFsdWUiLCJuZXh0VmFsdWUiLCJzZXR0ZXIiLCJ1c2VTbmFwUG9pbnRzIiwiYWN0aXZlU25hcFBvaW50UHJvcCIsInNldEFjdGl2ZVNuYXBQb2ludFByb3AiLCJmYWRlRnJvbUluZGV4Iiwib25TbmFwUG9pbnRDaGFuZ2UiLCJpc0xhc3RTbmFwUG9pbnQiLCJsZW5ndGgiLCJOdW1iZXIiLCJpc05hTiIsImFjdGl2ZVNuYXBQb2ludEluZGV4IiwiZmluZEluZGV4Iiwic25hcFBvaW50IiwiX3NuYXBQb2ludHNfbWFwIiwibWFwIiwiaGFzV2luZG93IiwiaXNQeCIsInNuYXBQb2ludEFzTnVtYmVyIiwid2lkdGgiLCJhY3RpdmVTbmFwUG9pbnRPZmZzZXQiLCJzbmFwVG9Qb2ludCIsImRpbWVuc2lvbiIsIl9zbmFwUG9pbnRzT2Zmc2V0X2ZpbmRJbmRleCIsIm5ld1NuYXBQb2ludEluZGV4Iiwic25hcFBvaW50RGltIiwidHJhbnNpdGlvbiIsImpvaW4iLCJvcGFjaXR5IiwiX3NuYXBQb2ludHNfZmluZEluZGV4IiwibmV3SW5kZXgiLCJkcmFnZ2VkRGlzdGFuY2UiLCJ2ZWxvY2l0eSIsImN1cnJlbnRQb3NpdGlvbiIsImlzT3ZlcmxheVNuYXBQb2ludCIsImlzRmlyc3QiLCJoYXNEcmFnZ2VkVXAiLCJjbG9zZXN0U25hcFBvaW50IiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJhYnMiLCJkaW0iLCJkcmFnRGlyZWN0aW9uIiwibmV3VmFsdWUiLCJnZXRQZXJjZW50YWdlRHJhZ2dlZCIsImFic0RyYWdnZWREaXN0YW5jZSIsImlzRHJhZ2dpbmdEb3duIiwiaXNPdmVybGF5U25hcFBvaW50T3JIaWdoZXIiLCJ0YXJnZXRTbmFwUG9pbnRJbmRleCIsInNuYXBQb2ludERpc3RhbmNlIiwicGVyY2VudGFnZURyYWdnZWQiLCJDTE9TRV9USFJFU0hPTEQiLCJTQ1JPTExfTE9DS19USU1FT1VUIiwiQk9SREVSX1JBRElVUyIsIk5FU1RFRF9ESVNQTEFDRU1FTlQiLCJXSU5ET1dfVE9QX09GRlNFVCIsIkRSQUdfQ0xBU1MiLCJSb290Iiwib3BlbiIsImNoaWxkcmVuIiwic2hvdWxkU2NhbGVCYWNrZ3JvdW5kIiwib25EcmFnUHJvcCIsIm9uUmVsZWFzZVByb3AiLCJzZXRCYWNrZ3JvdW5kQ29sb3JPblNjYWxlIiwiY2xvc2VUaHJlc2hvbGQiLCJzY3JvbGxMb2NrVGltZW91dCIsImZpeGVkIiwib25DbG9zZSIsImRpc2FibGVQcmV2ZW50U2Nyb2xsIiwiX2RyYXdlclJlZl9jdXJyZW50Iiwic2V0SXNPcGVuIiwic2V0SGFzQmVlbk9wZW5lZCIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwic2V0SXNEcmFnZ2luZyIsImp1c3RSZWxlYXNlZCIsInNldEp1c3RSZWxlYXNlZCIsIm9wZW5UaW1lIiwiZHJhZ1N0YXJ0VGltZSIsImRyYWdFbmRUaW1lIiwibGFzdFRpbWVEcmFnUHJldmVudGVkIiwiaXNBbGxvd2VkVG9EcmFnIiwibmVzdGVkT3BlbkNoYW5nZVRpbWVyIiwicG9pbnRlclN0YXJ0IiwicHJldmlvdXNEaWZmRnJvbUluaXRpYWwiLCJkcmF3ZXJIZWlnaHRSZWYiLCJpbml0aWFsRHJhd2VySGVpZ2h0IiwiRGF0ZSIsIm9uUmVsZWFzZVNuYXBQb2ludHMiLCJvbkRyYWdTbmFwUG9pbnRzIiwiZ2V0U25hcFBvaW50c1BlcmNlbnRhZ2VEcmFnZ2VkIiwiZ2V0U2NhbGUiLCJjb250YWlucyIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwiY2xpZW50WSIsImNsaWVudFgiLCJzaG91bGREcmFnIiwiaXNEcmFnZ2luZ0luRGlyZWN0aW9uIiwiX3dpbmRvd19nZXRTZWxlY3Rpb24iLCJoaWdobGlnaHRlZFRleHQiLCJnZXRTZWxlY3Rpb24iLCJ0b1N0cmluZyIsInN3aXBlQW1vdW50IiwiZGF0ZSIsImhhc0F0dHJpYnV0ZSIsImNsb3Nlc3QiLCJnZXRUaW1lIiwiZ2V0QXR0cmlidXRlIiwicGFyZW50Tm9kZSIsImRpcmVjdGlvbk11bHRpcGxpZXIiLCJub0Nsb3NlU25hcFBvaW50c1ByZUNvbmRpdGlvbiIsIndyYXBwZXIiLCJxdWVyeVNlbGVjdG9yIiwic25hcFBvaW50UGVyY2VudGFnZURyYWdnZWQiLCJjbGFzc0xpc3QiLCJhZGQiLCJkYW1wZW5lZERyYWdnZWREaXN0YW5jZSIsInRyYW5zbGF0ZVZhbHVlIiwibWluIiwib3BhY2l0eVZhbHVlIiwic2NhbGVWYWx1ZSIsImJvcmRlclJhZGl1c1ZhbHVlIiwibWF4IiwiYm9yZGVyUmFkaXVzIiwiX3dpbmRvd192aXN1YWxWaWV3cG9ydCIsIm9uVmlzdWFsVmlld3BvcnRDaGFuZ2UiLCJmb2N1c2VkRWxlbWVudCIsInZpc3VhbFZpZXdwb3J0SGVpZ2h0IiwiZGlmZkZyb21Jbml0aWFsIiwiZHJhd2VySGVpZ2h0Iiwib2Zmc2V0RnJvbVRvcCIsImFjdGl2ZVNuYXBQb2ludEhlaWdodCIsIm5ld0RyYXdlckhlaWdodCIsImNhbmNlbERyYWciLCJpZCIsImNsZWFyVGltZW91dCIsInJlc2V0RHJhd2VyIiwiY3VycmVudFN3aXBlQW1vdW50IiwidHJhbnNmb3JtT3JpZ2luIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uIiwicmVtb3ZlIiwidGltZVRha2VuIiwiZGlzdE1vdmVkIiwiX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF9oZWlnaHQiLCJ2aXNpYmxlRHJhd2VySGVpZ2h0Iiwic2Nyb2xsQmVoYXZpb3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2hpbGQiLCJodG1sQ2hpbGQiLCJzY3JvbGxXaWR0aCIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvIiwic2NhbGUiLCJpbml0aWFsRGltIiwiaW5pdGlhbFNjYWxlIiwibmV3U2NhbGUiLCJuZXdUcmFuc2xhdGUiLCJ0cmFuc2xhdGUiLCJQcm92aWRlciIsIkxPTkdfSEFORExFX1BSRVNTX1RJTUVPVVQiLCJET1VCTEVfVEFQX1RJTUVPVVQiLCJIYW5kbGUiLCJmb3J3YXJkUmVmIiwicHJldmVudEN5Y2xlIiwicmVzdCIsImNsb3NlVGltZW91dElkUmVmIiwic2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYiLCJoYW5kbGVTdGFydEN5Y2xlIiwiaGFuZGxlQ2FuY2VsSW50ZXJhY3Rpb24iLCJoYW5kbGVDeWNsZVNuYXBQb2ludHMiLCJjdXJyZW50U25hcEluZGV4IiwicG9pbnQiLCJuZXh0U25hcFBvaW50IiwiaGFuZGxlU3RhcnRJbnRlcmFjdGlvbiIsIm9uQ2xpY2siLCJvbkRvdWJsZUNsaWNrIiwib25Qb2ludGVyQ2FuY2VsIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlck1vdmUiLCJkaXNwbGF5TmFtZSIsIk92ZXJsYXkiLCJjb21wb3NlZFJlZiIsImhhc1NuYXBQb2ludHMiLCJvbk1vdXNlVXAiLCJDb250ZW50Iiwib25PcGVuQXV0b0ZvY3VzIiwib25Qb2ludGVyRG93bk91dHNpZGUiLCJvbkFuaW1hdGlvbkVuZCIsInBvaW50ZXJTdGFydFJlZiIsIndhc0JleW9uZFRoZVBvaW50UmVmIiwiaXNEZWx0YUluRGlyZWN0aW9uIiwiZGVsdGEiLCJ0aHJlc2hvbGQiLCJkZWx0YVkiLCJkZWx0YVgiLCJpc0RlbHRhWCIsImRGYWN0b3IiLCJpbmNsdWRlcyIsImlzUmV2ZXJzZURpcmVjdGlvbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbkZvY3VzT3V0c2lkZSIsIm9uRXNjYXBlS2V5RG93biIsInlQb3NpdGlvbiIsInhQb3NpdGlvbiIsInN3aXBlU3RhcnRUaHJlc2hvbGQiLCJwb2ludGVyVHlwZSIsImlzQWxsb3dlZFRvU3dpcGUiLCJvblBvaW50ZXJVcCIsIk5lc3RlZFJvb3QiLCJwIiwiRHJhd2VyIiwiVHJpZ2dlciIsIlBvcnRhbCIsIkNsb3NlIiwiVGl0bGUiLCJEZXNjcmlwdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/vaul@0.9.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/vaul/dist/index.mjs\n");

/***/ })

};
;